from collections.abc import Callable
from typing import Generic, TypeVar, overload

T = TypeVar("T")
U = TypeVar("U")

__all__ = [
    "FlextResult",
    "FlextResultOperations",
    "fail_result",
    "ok_result",
    "safe_call",
]

class FlextResult(Generic[T]):
    @overload
    def __init__(self, *, data: T) -> None: ...
    @overload
    def __init__(
        self,
        *,
        error: str,
        error_code: str | None = ...,
        error_data: dict[str, object] | None = ...,
    ) -> None: ...
    def __init__(
        self,
        *,
        data: T | None = ...,
        error: str | None = ...,
        error_code: str | None = ...,
        error_data: dict[str, object] | None = ...,
    ) -> None: ...
    @property
    def is_success(self) -> bool: ...
    @property
    def success(self) -> bool: ...
    @property
    def is_failure(self) -> bool: ...
    @property
    def is_fail(self) -> bool: ...
    @property
    def data(self) -> T: ...
    @property
    def error(self) -> str | None: ...
    @property
    def error_code(self) -> str | None: ...
    @property
    def error_data(self) -> dict[str, object]: ...
    @property
    def metadata(self) -> dict[str, object]: ...
    @classmethod
    def ok(cls, data: T, /) -> FlextResult[T]: ...
    @classmethod
    def failure(
        cls,
        error: str,
        /,
        *,
        error_code: str | None = ...,
        error_data: dict[str, object] | None = ...,
    ) -> FlextResult[T]: ...
    @classmethod
    def fail(
        cls,
        error: str,
        /,
        *,
        error_code: str | None = ...,
        error_data: dict[str, object] | None = ...,
    ) -> FlextResult[T]: ...
    @staticmethod
    def chain_results(*results: FlextResult[object]) -> FlextResult[list[object]]: ...
    def unwrap(self) -> T: ...
    def map(self, func: Callable[[T], U]) -> FlextResult[U]: ...
    def flat_map(self, func: Callable[[T], FlextResult[U]]) -> FlextResult[U]: ...
    def __bool__(self) -> bool: ...
    def unwrap_or(self, default: U) -> T | U: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def then(self, func: Callable[[T], FlextResult[U]]) -> FlextResult[U]: ...
    def bind(self, func: Callable[[T], FlextResult[U]]) -> FlextResult[U]: ...
    def or_else(self, alternative: FlextResult[T]) -> FlextResult[T]: ...
    def or_else_get(self, func: Callable[[], FlextResult[T]]) -> FlextResult[T]: ...
    def recover(self, func: Callable[[str], T]) -> FlextResult[T]: ...
    def recover_with(self, func: Callable[[str], FlextResult[T]]) -> FlextResult[T]: ...
    def tap(self, func: Callable[[T], None]) -> FlextResult[T]: ...
    def tap_error(self, func: Callable[[str], None]) -> FlextResult[T]: ...
    def filter(
        self, predicate: Callable[[T], bool], error_msg: str = ...
    ) -> FlextResult[T]: ...
    def zip_with(
        self, other: FlextResult[U], func: Callable[[T, U], object]
    ) -> FlextResult[object]: ...
    def to_either(self) -> tuple[T | None, str | None]: ...
    def to_exception(self) -> Exception | None: ...
    @classmethod
    def from_exception(cls, func: Callable[[], T]) -> FlextResult[T]: ...
    @staticmethod
    def combine(*results: FlextResult[object]) -> FlextResult[list[object]]: ...
    @staticmethod
    def all_success(*results: FlextResult[object]) -> bool: ...
    @staticmethod
    def any_success(*results: FlextResult[object]) -> bool: ...
    @classmethod
    def first_success(cls, *results: FlextResult[T]) -> FlextResult[T]: ...
    @classmethod
    def try_all(cls, *funcs: Callable[[], T]) -> FlextResult[T]: ...

# Backward compatibility alias
FlextResultOperations = FlextResult

_T = TypeVar("_T")

def safe_call(func: Callable[[], _T]) -> FlextResult[_T]: ...
def ok_result(data: _T) -> FlextResult[_T]: ...
def fail_result(
    error: str, error_code: str | None = ..., error_data: dict[str, object] | None = ...
) -> FlextResult[object]: ...
