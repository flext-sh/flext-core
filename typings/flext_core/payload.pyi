from collections.abc import Callable, Mapping
from typing import ClassVar, TypeVar

from _typeshed import Incomplete
from pydantic import BaseModel

from flext_core.mixins import FlextLoggableMixin, FlextSerializableMixin
from flext_core.result import FlextResult
from flext_core.typings import TValue

__all__ = [
    "FLEXT_SERIALIZATION_VERSION",
    "SERIALIZATION_FORMAT_BINARY",
    "SERIALIZATION_FORMAT_JSON",
    "SERIALIZATION_FORMAT_JSON_COMPRESSED",
    "FlextEvent",
    "FlextMessage",
    "FlextPayload",
    "create_cross_service_event",
    "create_cross_service_message",
    "get_serialization_metrics",
    "validate_cross_service_protocol",
]

FLEXT_SERIALIZATION_VERSION: Incomplete
SERIALIZATION_FORMAT_JSON: Incomplete
SERIALIZATION_FORMAT_JSON_COMPRESSED: Incomplete
SERIALIZATION_FORMAT_BINARY: str
_T = TypeVar("_T")

class FlextPayload[T](BaseModel, FlextSerializableMixin, FlextLoggableMixin):
    model_config: ClassVar[Incomplete]
    data: _T | None
    metadata: dict[str, object]
    @classmethod
    def create(cls, data: _T, **metadata: object) -> FlextResult[FlextPayload[_T]]: ...
    def with_metadata(self, **additional: TValue) -> FlextPayload[_T]: ...
    def enrich_metadata(self, additional: dict[str, object]) -> FlextPayload[_T]: ...
    @classmethod
    def create_from_dict(
        cls, data_dict: object
    ) -> FlextResult[FlextPayload[object]]: ...
    @classmethod
    def from_dict(
        cls, data_dict: dict[str, object] | Mapping[str, object] | object
    ) -> FlextResult[FlextPayload[object]]: ...
    def has_data(self) -> bool: ...
    def get_data(self) -> FlextResult[_T]: ...
    def get_data_or_default(self, default: _T) -> _T: ...
    def transform_data(
        self, transformer: Callable[[_T], object]
    ) -> FlextResult[FlextPayload[object]]: ...
    def get_metadata(
        self, key: str, default: object | None = None
    ) -> object | None: ...
    def has_metadata(self, key: str) -> bool: ...
    def serialize_data_for_json(self, value: _T | None) -> object: ...
    def serialize_metadata_enhanced(
        self, value: dict[str, object]
    ) -> dict[str, object]: ...
    def serialize_payload_for_api(
        self,
        serializer: Callable[[FlextPayload[_T]], dict[str, object] | object],
        info: object,
    ) -> dict[str, object] | object: ...
    def to_dict(self) -> dict[str, object]: ...
    def to_dict_basic(self) -> dict[str, object]: ...
    def to_cross_service_dict(
        self, *, include_type_info: bool = True, protocol_version: str = ...
    ) -> dict[str, object]: ...
    @classmethod
    def from_cross_service_dict(
        cls, cross_service_dict: dict[str, object]
    ) -> FlextResult[FlextPayload[_T]]: ...
    def to_json_string(
        self, *, compressed: bool = False, include_type_info: bool = True
    ) -> FlextResult[str]: ...
    @classmethod
    def from_json_string(cls, json_str: str) -> FlextResult[FlextPayload[T]]: ...
    def get_serialization_size(self) -> dict[str, int | float]: ...
    def __getattr__(self, name: str) -> object: ...
    def __contains__(self, key: str) -> bool: ...
    def __hash__(self) -> int: ...
    def has(self, key: str) -> bool: ...
    def get(self, key: str, default: object | None = None) -> object | None: ...
    def keys(self) -> list[str]: ...
    def items(self) -> list[tuple[str, object]]: ...

class FlextMessage(FlextPayload[str]):
    @classmethod
    def create_message(
        cls, message: str, *, level: str = "info", source: str | None = None
    ) -> FlextResult[FlextMessage]: ...
    @property
    def level(self) -> str: ...
    @property
    def source(self) -> str | None: ...
    @property
    def correlation_id(self) -> str | None: ...
    @property
    def text(self) -> str | None: ...
    def to_cross_service_dict(
        self, *, include_type_info: bool = True, protocol_version: str = ...
    ) -> dict[str, object]: ...
    @classmethod
    def from_cross_service_dict(
        cls, cross_service_dict: dict[str, object]
    ) -> FlextResult[FlextPayload[str]]: ...

class FlextEvent(FlextPayload[Mapping[str, object]]):
    @classmethod
    def create_event(
        cls,
        event_type: str,
        event_data: Mapping[str, object],
        *,
        aggregate_id: str | None = None,
        version: int | None = None,
    ) -> FlextResult[FlextEvent]: ...
    @property
    def event_type(self) -> str | None: ...
    @property
    def aggregate_id(self) -> str | None: ...
    @property
    def aggregate_type(self) -> str | None: ...
    @property
    def version(self) -> int | None: ...
    @property
    def correlation_id(self) -> str | None: ...
    def to_cross_service_dict(
        self, *, include_type_info: bool = True, protocol_version: str = ...
    ) -> dict[str, object]: ...
    @classmethod
    def from_cross_service_dict(
        cls, cross_service_dict: dict[str, object]
    ) -> FlextResult[FlextPayload[Mapping[str, object]]]: ...

def create_cross_service_event(
    event_type: str,
    event_data: dict[str, object],
    correlation_id: str | None = None,
    **kwargs: object,
) -> FlextResult[FlextEvent]: ...
def create_cross_service_message(
    message_text: str, correlation_id: str | None = None, **kwargs: object
) -> FlextResult[FlextMessage]: ...
def get_serialization_metrics(payload: object | None = None) -> dict[str, object]: ...
def validate_cross_service_protocol(payload: object) -> FlextResult[None]: ...
