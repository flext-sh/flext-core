from abc import ABC, abstractmethod
from collections.abc import Callable
from typing import ClassVar, TypeVar

from pydantic import BaseModel, ConfigDict, ValidationInfo, validate_call

from flext_core.result import FlextResult

__all__ = [
    "AdvancedEmailAddress",
    "AdvancedServiceName",
    "AutoGeneratedId",
    "ContextualEntityId",
    "DeduplicatedList",
    "EmailWithNormalization",
    "EntityIdWithGeneration",
    "FlextAbstractValidator",
    "FlextBaseValidator",
    "FlextDomainValidator",
    "FlextPredicates",
    "FlextPrefixedId",
    "FlextValidation",
    "FlextValidationConfig",
    "FlextValidationPipeline",
    "FlextValidationResult",
    "FlextValidators",
    "FormattedTimestamp",
    "NormalizedEmail",
    "NormalizedString",
    "PositiveNumber",
    "StringList",
    "UppercaseCode",
    "add_flext_prefix",
    "ensure_positive",
    "ensure_string_list",
    "flext_validate_email",
    "flext_validate_email_field",
    "flext_validate_entity_id",
    "flext_validate_numeric",
    "flext_validate_numeric_field",
    "flext_validate_required",
    "flext_validate_required_field",
    "flext_validate_service_name",
    "flext_validate_string",
    "flext_validate_string_field",
    "format_timestamp",
    "generate_id_if_missing",
    "normalize_email",
    "normalize_string",
    "validate_email_address_advanced",
    "validate_entity_id",
    "validate_list_with_deduplication",
    "validate_service_name_advanced",
    "validate_service_name_with_result",
    "validate_timestamp_with_fallback",
    "validate_version_number",
    "validate_with_result",
]

T = TypeVar("T")  # noqa: PYI001

class FlextAbstractValidator[T](ABC):
    @abstractmethod
    def validate(self, value: T) -> FlextResult[T]: ...

def normalize_string(v: object) -> str: ...
def normalize_email(v: object) -> str: ...
def ensure_string_list(v: object) -> list[str]: ...
def generate_id_if_missing(v: object) -> str: ...
def add_flext_prefix(v: str) -> str: ...
def ensure_positive(v: float) -> int | float: ...
def format_timestamp(v: str) -> str: ...
def validate_service_name_advanced(v: object) -> str: ...
def validate_email_address_advanced(v: object) -> str: ...
def validate_version_number(v: object) -> int: ...
def validate_timestamp_with_fallback(
    v: object, handler: Callable[[str], str], info: ValidationInfo
) -> str: ...
def validate_list_with_deduplication(
    v: object, handler: Callable[[object], list[str]], info: ValidationInfo
) -> list[str]: ...

# Type aliases for Pydantic validators
type NormalizedString = str
type NormalizedEmail = str
type StringList = list[str]
type AutoGeneratedId = str
type UppercaseCode = str
type FlextPrefixedId = str
type PositiveNumber = int
type FormattedTimestamp = str
type AdvancedServiceName = str
type AdvancedEmailAddress = str
type ContextualEntityId = str
type DeduplicatedList = list[str]
type EmailWithNormalization = str
type EntityIdWithGeneration = str

class _ValidationConfig(BaseModel):
    model_config: ClassVar[ConfigDict]
    field_name: str
    min_length: int
    max_length: int | None
    @classmethod
    def validate_max_length(cls, v: int | None, info: ValidationInfo) -> int | None: ...

class _ValidationResult(BaseModel):
    model_config: ClassVar[ConfigDict]
    is_valid: bool
    error_message: str
    field_name: str
    @classmethod
    def validate_error_message(cls, v: str, info: ValidationInfo) -> str: ...

class _BaseValidators:
    @staticmethod
    @validate_call
    def is_not_none(value: object) -> bool: ...
    @staticmethod
    @validate_call
    def is_string(value: object) -> bool: ...
    @staticmethod
    @validate_call
    def is_non_empty_string(value: object) -> bool: ...
    @staticmethod
    @validate_call
    def is_email(value: object) -> bool: ...
    @staticmethod
    @validate_call
    def is_uuid(value: object) -> bool: ...
    @staticmethod
    @validate_call
    def is_url(value: object) -> bool: ...
    @staticmethod
    @validate_call
    def has_min_length(value: object, min_length: int) -> bool: ...
    @staticmethod
    @validate_call
    def has_max_length(value: object, max_length: int) -> bool: ...
    @staticmethod
    @validate_call
    def matches_pattern(value: object, pattern: str) -> bool: ...
    @staticmethod
    @validate_call
    def is_callable(value: object) -> bool: ...
    @staticmethod
    @validate_call
    def is_list(value: object) -> bool: ...
    @staticmethod
    @validate_call
    def is_dict(value: object) -> bool: ...
    @staticmethod
    @validate_call
    def is_none(value: object) -> bool: ...

class _BasePredicates:
    @staticmethod
    @validate_call
    def is_positive(value: float) -> bool: ...
    @staticmethod
    @validate_call
    def is_negative(value: float) -> bool: ...
    @staticmethod
    @validate_call
    def is_zero(value: float) -> bool: ...
    @staticmethod
    @validate_call
    def is_in_range(value: float, min_val: float, max_val: float) -> bool: ...

# Public aliases for the classes
FlextValidationConfig = _ValidationConfig
FlextValidationResult = _ValidationResult
FlextValidators = _BaseValidators
FlextPredicates = _BasePredicates

@validate_call
def flext_validate_required_field(
    value: object, field_name: str = "field"
) -> FlextResult[object]: ...
@validate_call
def flext_validate_string_field(
    value: str,
    field_name: str = "field",
    min_length: int = 0,
    max_length: int | None = None,
) -> FlextResult[object]: ...
@validate_call
def flext_validate_numeric_field(
    value: float,
    field_name: str = "field",
    min_val: float | None = None,
    max_val: float | None = None,
) -> FlextResult[object]: ...
@validate_call
def flext_validate_email_field(
    value: str, field_name: str = "field"
) -> FlextResult[object]: ...
@validate_call
def flext_validate_entity_id(entity_id: str) -> FlextResult[str]: ...

class FlextValidation(FlextValidators):
    Validators = FlextValidators
    @staticmethod
    @validate_call
    def flext_validate_entity_id(entity_id: str) -> FlextResult[str]: ...
    @staticmethod
    @validate_call
    def flext_validate_non_empty_string(value: object) -> FlextResult[str]: ...
    @staticmethod
    @validate_call
    def flext_validate_required_field(
        value: object, field_name: str = "field"
    ) -> FlextResult[object]: ...
    @staticmethod
    @validate_call
    def flext_validate_string_field(
        value: str,
        field_name: str = "field",
        min_length: int = 0,
        max_length: int | None = None,
    ) -> FlextResult[object]: ...
    @staticmethod
    @validate_call
    def flext_validate_numeric_field(
        value: float,
        field_name: str = "field",
        min_val: float | None = None,
        max_val: float | None = None,
    ) -> FlextResult[object]: ...
    @staticmethod
    @validate_call
    def flext_validate_email_field(
        value: str, field_name: str = "field"
    ) -> FlextResult[object]: ...
    @classmethod
    @validate_call
    def validate(cls, value: object) -> FlextResult[object]: ...
    @staticmethod
    @validate_call
    def chain(*validators: Callable[[object], bool]) -> Callable[[object], bool]: ...
    @staticmethod
    @validate_call
    def any_of(*validators: Callable[[object], bool]) -> Callable[[object], bool]: ...
    @staticmethod
    @validate_call
    def create_validation_config(
        field_name: str, min_length: int = 0, max_length: int | None = None
    ) -> FlextValidationConfig: ...
    @classmethod
    @validate_call
    def safe_validate(
        cls, value: object, validator: Callable[[object], bool]
    ) -> FlextResult[object]: ...

@validate_call
def flext_validate_required(
    value: object, field_name: str = "field"
) -> FlextValidationResult: ...
@validate_call
def flext_validate_string(
    value: str,
    field_name: str = "field",
    min_length: int = 0,
    max_length: int | None = None,
) -> FlextValidationResult: ...
@validate_call
def flext_validate_numeric(
    value: float,
    field_name: str = "field",
    min_val: float | None = None,
    max_val: float | None = None,
) -> FlextValidationResult: ...
@validate_call
def flext_validate_email(
    value: str, field_name: str = "field"
) -> FlextValidationResult: ...
@validate_call
def flext_validate_service_name(name: str) -> bool: ...
@validate_call
def validate_with_result(
    value: object,
    validator: Callable[[object], bool],
    error_message: str = "Validation failed",
) -> FlextResult[object]: ...
@validate_call
def validate_entity_id(entity_id: str) -> FlextResult[str]: ...
@validate_call
def validate_service_name_with_result(name: str) -> FlextResult[str]: ...

class FlextValidationPipeline:
    validators: list[Callable[[object], FlextResult[object]]]
    @validate_call
    def __init__(self) -> None: ...
    @validate_call
    def add_validator(
        self, validator: Callable[[object], FlextResult[object]]
    ) -> None: ...
    @validate_call
    def validate(self, value: object) -> FlextResult[object]: ...

class FlextDomainValidator(FlextAbstractValidator[T]):
    business_rules: list[Callable[[object], bool]] | None
    @validate_call
    def __init__(
        self, business_rules: list[Callable[[object], bool]] | None = None
    ) -> None: ...
    @validate_call
    def validate_value(self, value: T) -> FlextResult[T]: ...
    @validate_call
    def validate(self, value: T) -> FlextResult[T]: ...

FlextBaseValidator = FlextAbstractValidator
