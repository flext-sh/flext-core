from abc import abstractmethod
from collections.abc import Awaitable, Callable, Iterator
from pathlib import Path
from typing import Protocol

from flext_core.result import FlextResult

__all__ = [
    "FlextAlertsProtocol",
    "FlextAsyncFactory",
    "FlextAsyncHandler",
    "FlextAsyncMiddleware",
    "FlextAsyncService",
    "FlextAuthProtocol",
    "FlextAuthorizingHandler",
    "FlextConfigurable",
    "FlextConnectionProtocol",
    "FlextDecoratedFunction",
    "FlextDomainEvent",
    "FlextEventProcessor",
    "FlextEventPublisher",
    "FlextEventStore",
    "FlextEventStreamReader",
    "FlextEventSubscriber",
    "FlextFactory",
    "FlextLoggerProtocol",
    "FlextMessageHandler",
    "FlextMessageHandler",
    "FlextMetricsCollector",
    "FlextMetricsProtocol",
    "FlextMiddleware",
    "FlextObservabilityProtocol",
    "FlextPlugin",
    "FlextPluginContext",
    "FlextPluginLoader",
    "FlextPluginRegistry",
    "FlextProjectionBuilder",
    "FlextRepository",
    "FlextService",
    "FlextSpanProtocol",
    "FlextTracerProtocol",
    "FlextUnitOfWork",
    "FlextValidatingHandler",
    "FlextValidationRule",
    "FlextValidator",
    "TFactory",
]

type TFactory = Callable[[], object]
type FlextMessageHandler = FlextMessageHandler

class FlextConnectionProtocol(Protocol):
    def test_connection(self) -> FlextResult[bool]: ...
    def get_connection_string(self) -> str: ...
    def close_connection(self) -> FlextResult[None]: ...

class FlextAuthProtocol(Protocol):
    def authenticate(
        self, credentials: dict[str, object]
    ) -> FlextResult[dict[str, object]]: ...
    def authorize(
        self, user_info: dict[str, object], resource: str
    ) -> FlextResult[bool]: ...
    def refresh_token(self, refresh_token: str) -> FlextResult[dict[str, object]]: ...

class FlextObservabilityProtocol(Protocol):
    def record_metric(
        self, name: str, value: float, tags: dict[str, str] | None = None
    ) -> FlextResult[None]: ...
    def start_trace(self, operation_name: str) -> FlextResult[str]: ...
    def health_check(self) -> FlextResult[dict[str, object]]: ...

class FlextValidator(Protocol):
    def validate(self, value: object) -> FlextResult[object]: ...

class FlextValidationRule(Protocol):
    def apply(self, value: object, field_name: str) -> FlextResult[object]: ...
    def get_error_message(self, field_name: str, value: object) -> str: ...

class FlextService(Protocol):
    @abstractmethod
    def start(self) -> FlextResult[None]: ...
    @abstractmethod
    def stop(self) -> FlextResult[None]: ...
    @abstractmethod
    def health_check(self) -> FlextResult[dict[str, object]]: ...

class FlextConfigurable(Protocol):
    def configure(self, config: dict[str, object]) -> FlextResult[None]: ...
    def get_config(self) -> dict[str, object]: ...

class FlextMessageHandler(Protocol):
    def handle(self, message: object) -> FlextResult[object]: ...
    def can_handle(self, message_type: type) -> bool: ...

class FlextValidatingHandler(Protocol):
    def validate(self, message: object) -> FlextResult[object]: ...
    def handle(self, message: object) -> FlextResult[object]: ...

class FlextAuthorizingHandler(Protocol):
    def authorize(
        self, message: object, context: dict[str, object]
    ) -> FlextResult[bool]: ...
    def handle(self, message: object) -> FlextResult[object]: ...

class FlextEventProcessor(Protocol):
    def process_event(self, event: dict[str, object]) -> FlextResult[None]: ...
    def can_process(self, event_type: str) -> bool: ...

class FlextMetricsCollector(Protocol):
    def collect_metrics(self, operation: str, duration: float) -> FlextResult[None]: ...
    def get_metrics_summary(self) -> dict[str, object]: ...

type FlextDecoratedFunction = Callable[..., object]

class FlextLoggerProtocol(Protocol):
    def trace(self, message: str, **kwargs: object) -> None: ...
    def debug(self, message: str, **kwargs: object) -> None: ...
    def info(self, message: str, **kwargs: object) -> None: ...
    def warning(self, message: str, **kwargs: object) -> None: ...
    def error(self, message: str, **kwargs: object) -> None: ...
    def critical(self, message: str, **kwargs: object) -> None: ...
    def exception(
        self, message: str, *, exc_info: bool = True, **kwargs: object
    ) -> None: ...

class FlextSpanProtocol(Protocol):
    def set_tag(self, key: str, value: str) -> None: ...
    def log_event(self, event_name: str, payload: dict[str, object]) -> None: ...
    def finish(self) -> None: ...

class FlextTracerProtocol(Protocol):
    def start_span(self, operation_name: str) -> FlextSpanProtocol: ...
    def inject_context(self, headers: dict[str, str]) -> None: ...

class FlextMetricsProtocol(Protocol):
    def increment_counter(
        self, name: str, tags: dict[str, str] | None = None
    ) -> None: ...
    def record_gauge(
        self, name: str, value: float, tags: dict[str, str] | None = None
    ) -> None: ...
    def record_histogram(
        self, name: str, value: float, tags: dict[str, str] | None = None
    ) -> None: ...

class FlextAlertsProtocol(Protocol):
    def info(self, message: str, **kwargs: object) -> None: ...
    def warning(self, message: str, **kwargs: object) -> None: ...
    def error(self, message: str, **kwargs: object) -> None: ...
    def critical(self, message: str, **kwargs: object) -> None: ...

class FlextPlugin(Protocol):
    @abstractmethod
    def initialize(self, context: FlextPluginContext) -> FlextResult[None]: ...
    @abstractmethod
    def shutdown(self) -> FlextResult[None]: ...
    @abstractmethod
    def get_info(self) -> dict[str, object]: ...

class FlextPluginContext(Protocol):
    def get_service(self, service_name: str) -> FlextResult[object]: ...
    def get_config(self) -> dict[str, object]: ...
    def get_logger(self) -> FlextLoggerProtocol: ...

class FlextPluginRegistry(Protocol):
    def register_plugin(self, plugin: FlextPlugin) -> FlextResult[None]: ...
    def get_plugin(self, plugin_name: str) -> FlextResult[FlextPlugin]: ...
    def list_plugins(self) -> list[str]: ...

class FlextPluginLoader(Protocol):
    def load_plugin(self, plugin_path: str | Path) -> FlextResult[FlextPlugin]: ...
    def load_plugins_from_directory(
        self, directory: str | Path
    ) -> list[FlextPlugin]: ...
    def unload_plugin(self, plugin: FlextPlugin) -> FlextResult[None]: ...

class FlextRepository[T](Protocol):
    @abstractmethod
    def get_by_id(self, entity_id: str) -> FlextResult[T | None]: ...
    @abstractmethod
    def save(self, entity: T) -> FlextResult[T]: ...
    @abstractmethod
    def delete(self, entity_id: str) -> FlextResult[None]: ...
    @abstractmethod
    def find_all(self) -> FlextResult[list[T]]: ...

class FlextUnitOfWork(Protocol):
    @abstractmethod
    def begin(self) -> FlextResult[None]: ...
    @abstractmethod
    def commit(self) -> FlextResult[None]: ...
    @abstractmethod
    def rollback(self) -> FlextResult[None]: ...

class FlextDomainEvent(Protocol):
    event_id: str
    event_type: str
    aggregate_id: str
    event_version: int
    timestamp: str
    def to_dict(self) -> dict[str, object]: ...
    @classmethod
    def from_dict(cls, data: dict[str, object]) -> FlextDomainEvent: ...

class FlextEventStore(Protocol):
    @abstractmethod
    def save_events(
        self, aggregate_id: str, events: list[FlextDomainEvent], expected_version: int
    ) -> FlextResult[None]: ...
    @abstractmethod
    def get_events(self, aggregate_id: str) -> FlextResult[list[FlextDomainEvent]]: ...
    @abstractmethod
    def get_events_from_version(
        self, aggregate_id: str, from_version: int
    ) -> FlextResult[list[FlextDomainEvent]]: ...

class FlextEventPublisher(Protocol):
    @abstractmethod
    def publish(self, event: FlextDomainEvent) -> FlextResult[None]: ...
    @abstractmethod
    def publish_batch(self, events: list[FlextDomainEvent]) -> FlextResult[None]: ...

class FlextEventSubscriber(Protocol):
    @abstractmethod
    def handle_event(self, event: FlextDomainEvent) -> FlextResult[None]: ...
    @abstractmethod
    def can_handle(self, event_type: str) -> bool: ...

class FlextEventStreamReader(Protocol):
    @abstractmethod
    def read_stream(
        self, stream_name: str, from_position: int = 0
    ) -> FlextResult[Iterator[FlextDomainEvent]]: ...
    @abstractmethod
    def subscribe_to_stream(
        self, stream_name: str, handler: Callable[[FlextDomainEvent], None]
    ) -> FlextResult[None]: ...

class FlextProjectionBuilder(Protocol):
    @abstractmethod
    def build_projection(
        self, events: list[FlextDomainEvent]
    ) -> FlextResult[dict[str, object]]: ...
    @abstractmethod
    def update_projection(
        self, projection: dict[str, object], event: FlextDomainEvent
    ) -> FlextResult[dict[str, object]]: ...

class FlextAsyncHandler(Protocol):
    async def handle_async(self, message: object) -> FlextResult[object]: ...
    def can_handle(self, message_type: type) -> bool: ...

class FlextAsyncService(Protocol):
    async def start_async(self) -> FlextResult[None]: ...
    async def stop_async(self) -> FlextResult[None]: ...
    async def health_check_async(self) -> FlextResult[dict[str, object]]: ...

class FlextFactory[T](Protocol):
    def create(self, **kwargs: object) -> FlextResult[T]: ...

class FlextAsyncFactory[T](Protocol):
    async def create_async(self, **kwargs: object) -> FlextResult[T]: ...

class FlextMiddleware(Protocol):
    def process(
        self, request: object, next_handler: Callable[[object], FlextResult[object]]
    ) -> FlextResult[object]: ...

class FlextAsyncMiddleware(Protocol):
    async def process_async(
        self,
        request: object,
        next_handler: Callable[[object], Awaitable[FlextResult[object]]],
    ) -> FlextResult[object]: ...
