from collections.abc import Callable
from types import ModuleType, TracebackType

from flext_core.protocols import p
from flext_core.typings import T, t

class RuntimeResult[T]:
    def __class_getitem__(cls, item: type[T]) -> type[p.Result[T]]: ...
    def __init__(
        self,
        value: T | None = None,
        error: str | None = None,
        error_code: str | None = None,
        error_data: t.ConfigurationMapping | None = None,
        *,
        is_success: bool = True,
    ) -> None: ...
    @property
    def value(self) -> T: ...
    @property
    def data(self) -> T: ...
    @property
    def result(self) -> object: ...
    @property
    def is_success(self) -> bool: ...
    @property
    def is_failure(self) -> bool: ...
    @property
    def error(self) -> str | None: ...
    @property
    def error_code(self) -> str | None: ...
    @property
    def error_data(self) -> t.ConfigurationMapping | None: ...
    def unwrap(self) -> T: ...
    def unwrap_or(self, default: T) -> T: ...
    def unwrap_or_else(self, func: Callable[[], T]) -> T: ...
    def map[U](self, func: Callable[[T], U]) -> RuntimeResult[U]: ...
    def flat_map[U](
        self,
        func: Callable[[T], RuntimeResult[U]],
    ) -> RuntimeResult[U]: ...
    def and_then[U](
        self,
        func: Callable[[T], RuntimeResult[U]],
    ) -> RuntimeResult[U]: ...
    def fold[U](
        self,
        on_failure: Callable[[str], U],
        on_success: Callable[[T], U],
    ) -> U: ...
    def tap(self, func: Callable[[T], None]) -> RuntimeResult[T]: ...
    def tap_error(self, func: Callable[[str], None]) -> RuntimeResult[T]: ...
    def map_error(self, func: Callable[[str], str]) -> RuntimeResult[T]: ...
    def filter(self, predicate: Callable[[T], bool]) -> RuntimeResult[T]: ...
    def alt(self, func: Callable[[str], str]) -> RuntimeResult[T]: ...
    def lash(self, func: Callable[[str], RuntimeResult[T]]) -> RuntimeResult[T]: ...
    def recover(self, func: Callable[[str], T]) -> RuntimeResult[T]: ...
    def flow_through[U](
        self,
        *funcs: Callable[[T | U], RuntimeResult[U]],
    ) -> RuntimeResult[U]: ...
    def __or__(self, default: T) -> T: ...
    def __bool__(self) -> bool: ...
    def __enter__(self) -> RuntimeResult[T]: ...
    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        exc_val: BaseException | None,
        exc_tb: TracebackType | None,
    ) -> None: ...
    @classmethod
    def ok(cls, value: T) -> RuntimeResult[T]: ...
    @classmethod
    def fail(
        cls,
        error: str | None,
        error_code: str | None = None,
        error_data: t.ConfigurationMapping | None = None,
    ) -> RuntimeResult[T]: ...

class FlextRuntime:
    class RuntimeResult[T]:
        def __class_getitem__(cls, item: type[T]) -> type[p.Result[T]]: ...
        def __init__(
            self,
            value: T | None = None,
            error: str | None = None,
            error_code: str | None = None,
            error_data: t.ConfigurationMapping | None = None,
            *,
            is_success: bool = True,
        ) -> None: ...
        @property
        def value(self) -> T: ...
        @property
        def data(self) -> T: ...
        @property
        def result(self) -> object: ...
        @property
        def is_success(self) -> bool: ...
        @property
        def is_failure(self) -> bool: ...
        @property
        def error(self) -> str | None: ...
        @property
        def error_code(self) -> str | None: ...
        @property
        def error_data(self) -> t.ConfigurationMapping | None: ...
        def unwrap(self) -> T: ...
        def unwrap_or(self, default: T) -> T: ...
        def unwrap_or_else(self, func: Callable[[], T]) -> T: ...
        def map[U](self, func: Callable[[T], U]) -> FlextRuntime.RuntimeResult[U]: ...
        def flat_map[U](
            self,
            func: Callable[[T], FlextRuntime.RuntimeResult[U]],
        ) -> FlextRuntime.RuntimeResult[U]: ...
        def and_then[U](
            self,
            func: Callable[[T], FlextRuntime.RuntimeResult[U]],
        ) -> FlextRuntime.RuntimeResult[U]: ...
        def fold[U](
            self,
            on_failure: Callable[[str], U],
            on_success: Callable[[T], U],
        ) -> U: ...
        def tap(self, func: Callable[[T], None]) -> FlextRuntime.RuntimeResult[T]: ...
        def tap_error(
            self,
            func: Callable[[str], None],
        ) -> FlextRuntime.RuntimeResult[T]: ...
        def map_error(
            self,
            func: Callable[[str], str],
        ) -> FlextRuntime.RuntimeResult[T]: ...
        def filter(
            self,
            predicate: Callable[[T], bool],
        ) -> FlextRuntime.RuntimeResult[T]: ...
        def alt(self, func: Callable[[str], str]) -> FlextRuntime.RuntimeResult[T]: ...
        def lash(
            self,
            func: Callable[[str], FlextRuntime.RuntimeResult[T]],
        ) -> FlextRuntime.RuntimeResult[T]: ...
        def recover(
            self,
            func: Callable[[str], T],
        ) -> FlextRuntime.RuntimeResult[T]: ...
        def flow_through[U](
            self,
            *funcs: Callable[[T | U], FlextRuntime.RuntimeResult[U]],
        ) -> FlextRuntime.RuntimeResult[U]: ...
        def __or__(self, default: T) -> T: ...
        def __bool__(self) -> bool: ...
        def __enter__(self) -> FlextRuntime.RuntimeResult[T]: ...
        def __exit__(
            self,
            exc_type: type[BaseException] | None,
            exc_val: BaseException | None,
            exc_tb: TracebackType | None,
        ) -> None: ...
        @classmethod
        def ok(cls, value: T) -> FlextRuntime.RuntimeResult[T]: ...
        @classmethod
        def fail(
            cls,
            error: str | None,
            error_code: str | None = None,
            error_data: t.ConfigurationMapping | None = None,
        ) -> FlextRuntime.RuntimeResult[T]: ...

    @staticmethod
    def is_dict_like(value: object) -> bool: ...
    @staticmethod
    def is_list_like(value: object) -> bool: ...
    @staticmethod
    def safe_get_attribute(
        obj: t.GeneralValueType,
        attr: str,
        default: t.GeneralValueType = None,
    ) -> t.GeneralValueType: ...
    @staticmethod
    def is_sequence_type(type_hint: t.TypeHintSpecifier) -> bool: ...
    @staticmethod
    def extract_generic_args(
        type_hint: t.TypeHintSpecifier,
    ) -> tuple[t.GenericTypeArgument, ...]: ...
    @staticmethod
    def normalize_to_general_value(val: object) -> t.GeneralValueType: ...
    @staticmethod
    def normalize_to_metadata_value(
        val: t.GeneralValueType,
    ) -> t.MetadataAttributeValue: ...
    @staticmethod
    def structlog() -> ModuleType: ...
    @staticmethod
    def create_instance[T](class_type: type[T]) -> T: ...
    @staticmethod
    def get_logger(
        name: str | None = None,
    ) -> p.Log.StructlogLogger: ...
    @staticmethod
    def dependency_providers() -> ModuleType: ...
    @staticmethod
    def dependency_containers() -> ModuleType: ...
    @classmethod
    def ensure_structlog_configured(cls) -> None: ...

    class DependencyIntegration:
        Provide: object
        inject: object
        @classmethod
        def create_layered_bridge(
            cls,
            config: t.ConfigurationMapping | None = None,
        ) -> tuple[object, object, object]: ...
        @classmethod
        def create_container(
            cls,
            *,
            config: t.ConfigurationMapping | None = None,
            services: object | None = None,
            factories: object | None = None,
            resources: object | None = None,
            wire_modules: object | None = None,
            wire_packages: object | None = None,
            wire_classes: object | None = None,
            factory_cache: bool = True,
        ) -> object: ...
        @staticmethod
        def bind_configuration(
            di_container: object,
            config: t.ConfigurationMapping | None,
        ) -> object: ...
        @staticmethod
        def bind_configuration_provider(
            configuration_provider: object,
            config: t.ConfigurationMapping | None,
        ) -> object: ...
        @staticmethod
        def register_object[T](
            di_container: object,
            name: str,
            instance: T,
        ) -> object: ...
        @staticmethod
        def register_factory[T](
            di_container: object,
            name: str,
            factory: object,
            *,
            cache: bool = True,
        ) -> object: ...
        @staticmethod
        def register_resource[T](
            di_container: object,
            name: str,
            factory: object,
        ) -> object: ...
        @staticmethod
        def wire(
            container: object,
            *,
            modules: object | None = None,
            packages: object | None = None,
            classes: object | None = None,
        ) -> None: ...

    class Integration:
        @staticmethod
        def track_service_resolution(name: str, resolved: bool = True) -> None: ...
        @staticmethod
        def track_domain_event(
            event_name: str,
            aggregate_id: str | None = None,
            event_data: object | None = None,
        ) -> None: ...
