"""Extended test coverage for fields.py module.

Copyright (c) 2025 FLEXT Team. All rights reserved.
SPDX-License-Identifier: MIT
"""

from __future__ import annotations

import uuid
from datetime import UTC, datetime
from typing import cast

import pytest
from hypothesis import given, strategies as st

from flext_core import (
    FlextConfig,
    FlextConstants,
    FlextFields,
    FlextTypes,
    FlextUtilities,
    FlextValidations,
)

pytestmark = [pytest.mark.unit, pytest.mark.core]


class TestFlextFieldsCore:
    """Test FlextFields.Core functionality."""

    def test_base_field_creation_with_validation(self) -> None:
        """Test field creation with validation."""
        with pytest.raises(ValueError):
            FlextUtilities.FieldFactory.create_string_field(
                "", min_length=1
            )  # Empty name

        with pytest.raises(ValueError):
            FlextUtilities.FieldFactory.create_string_field(
                "   ", min_length=1
            )  # Whitespace only

    def test_string_field_comprehensive(self) -> None:
        """Test string field validation comprehensively."""
        # Test valid string field creation
        result = FlextUtilities.FieldFactory.create_string_field(
            "test",
            min_length=3,
            max_length=10,
        )

        assert result == "test"
        assert len(result) >= 3
        assert len(result) <= 10

        # Test validation with various inputs
        # Valid string
        valid_result = FlextUtilities.FieldFactory.create_string_field(
            "hello", min_length=3, max_length=10
        )
        assert valid_result == "hello"

        # Too short - should raise ValueError
        with pytest.raises(ValueError, match="too short"):
            FlextUtilities.FieldFactory.create_string_field("ab", min_length=3)

        # Too long - should raise ValueError
        with pytest.raises(ValueError, match="too long"):
            FlextUtilities.FieldFactory.create_string_field(
                "verylongstringthatiswaytoolong", max_length=10
            )

        # Pattern validation using FlextValidations
        pattern_result = FlextValidations.validate_string_field(
            "Hello123", pattern=r"^[a-z]+$"
        )
        assert pattern_result.is_failure
        assert pattern_result.error is not None
        assert "pattern" in pattern_result.error.lower()

    def test_integer_field_comprehensive(self) -> None:
        """Test numeric field validation comprehensively."""
        # Valid integer
        result = FlextValidations.validate_numeric_field(25, min_value=0, max_value=100)
        assert result.is_success
        assert result.data is True

        # Boolean should fail
        result = FlextValidations.validate_numeric_field(True)
        assert result.is_failure

        # Too small
        result = FlextValidations.validate_numeric_field(-5, min_value=0)
        assert result.is_failure
        assert result.error is not None
        assert "too small" in result.error.lower()

        # Too large
        result = FlextValidations.validate_numeric_field(150, max_value=100)
        assert result.is_failure
        assert result.error is not None
        assert "too large" in result.error.lower()

    def test_float_field_comprehensive(self) -> None:
        """Test float field validation comprehensively."""
        # Valid float
        result = FlextValidations.validate_numeric_field(
            25.7, min_value=0.0, max_value=100.0
        )
        assert result.is_success

        # Boolean should fail
        result = FlextValidations.validate_numeric_field(True)
        assert result.is_failure

        # Integer should be accepted
        result = FlextValidations.validate_numeric_field(
            25, min_value=0.0, max_value=100.0
        )
        assert result.is_success

        # Test with decimal precision (using string representation for precision check)
        result = FlextValidations.validate_numeric_field(
            25.123456, min_value=0.0, max_value=100.0
        )
        assert result.is_success

    def test_boolean_field_comprehensive(self) -> None:
        """Test boolean field validation comprehensively."""
        # Direct boolean - valid
        assert isinstance(True, bool)
        assert isinstance(False, bool)

        # Test various boolean-like values (current API doesn't auto-convert strings)
        # For now, just test that actual booleans are accepted
        valid_booleans = [True, False]
        for val in valid_booleans:
            assert isinstance(val, bool)

        # Test invalid types
        invalid_values = ["true", "false", 1, 0, None]
        for val in invalid_values:
            assert not isinstance(val, bool)

    def test_email_field_comprehensive(self) -> None:
        """Test email field validation comprehensively."""
        # Valid email
        result = FlextValidations.FieldValidators.validate_email("test@example.com")
        assert result.is_success

        # Invalid email - no @
        result = FlextValidations.FieldValidators.validate_email("testexample.com")
        assert result.is_failure

    def test_uuid_field_comprehensive(self) -> None:
        """Test UUID field validation comprehensively."""
        # Valid UUID
        valid_uuid = str(uuid.uuid4())
        result = FlextValidations.FieldValidators.validate_uuid(valid_uuid)
        assert result.is_success

        # Invalid UUID
        result = FlextValidations.FieldValidators.validate_uuid("not-a-uuid")
        assert result.is_failure

    def test_datetime_field_comprehensive(self) -> None:
        """Test DateTimeField comprehensively."""
        now = datetime.now(UTC)
        field = FlextFields.Core.DateTimeField(
            "datetime_field",
            date_format="%Y-%m-%d %H:%M:%S",
            min_date=datetime(2020, 1, 1, tzinfo=UTC),
            max_date=datetime(2030, 12, 31, tzinfo=UTC),
        )

        # Valid datetime object
        result = field.validate(now)
        assert result.success

        # Valid ISO string
        result = field.validate("2025-06-15T10:30:00Z")
        assert result.success

        # Invalid format
        result = field.validate("invalid-date")
        assert result.failure

        # Date too early
        early_date = datetime(2019, 1, 1, tzinfo=UTC)
        result = field.validate(early_date)
        assert result.failure
        assert "too early" in (result.error or "").lower()

    def test_field_metadata(self) -> None:
        """Test field metadata extraction."""
        field = FlextFields.Core.StringField(
            "test_field",
            required=True,
            default="default_value",
            description="Test description",
            min_length=5,
        )

        metadata = field.get_metadata()
        assert metadata["name"] == "test_field"
        assert metadata["type"] == "string"
        assert metadata["required"] is True
        assert metadata["default"] == "default_value"
        assert metadata["description"] == "Test description"

    def test_field_type_property(self) -> None:
        """Test field_type property."""
        string_field = FlextFields.Core.StringField("test")
        assert string_field.field_type == "string"

        integer_field = FlextFields.Core.IntegerField("test")
        assert integer_field.field_type == "integer"

        boolean_field = FlextFields.Core.BooleanField("test")
        assert boolean_field.field_type == "boolean"


class TestFlextFieldsValidation:
    """Test FlextFields.Validation functionality."""

    def test_validate_field(self) -> None:
        """Test validate_field static method."""
        field = FlextFields.Core.StringField("test", min_length=3)

        result = FlextFields.Validation.validate_field(
            cast("FlextFields.Core.BaseField[object]", field),
            "hello",
        )
        assert result.success
        assert result.unwrap() == "hello"

        result = FlextFields.Validation.validate_field(
            cast("FlextFields.Core.BaseField[object]", field),
            "hi",
        )
        assert result.failure

    def test_validate_multiple_fields(self) -> None:
        """Test validate_multiple_fields static method."""
        fields: list[FlextFields.Core.BaseField[object]] = [
            cast(
                "FlextFields.Core.BaseField[object]",
                FlextFields.Core.StringField("name", min_length=2),
            ),
            cast(
                "FlextFields.Core.BaseField[object]",
                FlextFields.Core.IntegerField("age", min_value=0),
            ),
            cast(
                "FlextFields.Core.BaseField[object]",
                FlextFields.Core.EmailField("email"),
            ),
        ]

        values: FlextTypes.Core.Dict = {
            "name": "John",
            "age": 25,
            "email": "john@example.com",
        }

        result = FlextFields.Validation.validate_multiple_fields(fields, values)
        assert result.success
        assert result.unwrap()["name"] == "John"
        assert result.unwrap()["age"] == 25

        # Test with invalid values
        invalid_values = {
            "name": "J",  # Too short
            "age": -5,  # Too small
            "email": "invalid-email",
        }

        result = FlextFields.Validation.validate_multiple_fields(fields, invalid_values)
        assert result.failure
        assert "name:" in (result.error or "")
        assert "age:" in (result.error or "")


class TestFlextFieldsRegistry:
    """Test FlextFields.Registry functionality."""

    def test_field_registry_basic(self) -> None:
        """Test basic FieldRegistry operations."""
        registry = FlextFields.Registry.FieldRegistry()
        field = FlextFields.Core.StringField("test_field")

        # Register field
        reg_result = registry.register_field(
            "test",
            cast("FlextFields.Core.BaseField[object]", field),
        )
        assert reg_result.success

        # Get field
        get_result = registry.get_field("test")
        assert get_result.success
        assert get_result.unwrap().name == "test_field"

        # Get non-existent field
        missing_result = registry.get_field("missing")
        assert missing_result.failure

    def test_field_registry_validation(self) -> None:
        """Test FieldRegistry validation."""
        registry = FlextFields.Registry.FieldRegistry()
        field = FlextFields.Core.StringField("test_field")

        # Empty name
        result = registry.register_field(
            "",
            cast("FlextFields.Core.BaseField[object]", field),
        )
        assert result.failure

        result = registry.register_field(
            "   ",
            cast("FlextFields.Core.BaseField[object]", field),
        )
        assert result.failure

        # Get with empty name
        result_get_empty = registry.get_field("")
        assert result_get_empty.failure

    def test_field_type_registration(self) -> None:
        """Test field type registration."""
        registry = FlextFields.Registry.FieldRegistry()

        # Register field type
        result = registry.register_field_type(
            "custom",
            cast(
                "type[FlextFields.Core.BaseField[object]]",
                FlextFields.Core.StringField,
            ),
        )
        assert result.success

        # Get field type
        type_result = registry.get_field_type("custom")
        assert type_result.success
        assert type_result.unwrap() == FlextFields.Core.StringField

        # Get non-existent type
        missing_type_result = registry.get_field_type("missing")
        assert missing_type_result.failure

    def test_registry_listing(self) -> None:
        """Test registry listing methods."""
        registry = FlextFields.Registry.FieldRegistry()
        field = FlextFields.Core.StringField("test")

        registry.register_field(
            "field1",
            cast("FlextFields.Core.BaseField[object]", field),
        )
        registry.register_field(
            "field2",
            cast("FlextFields.Core.BaseField[object]", field),
        )
        registry.register_field_type(
            "type1",
            cast(
                "type[FlextFields.Core.BaseField[object]]",
                FlextFields.Core.StringField,
            ),
        )

        fields = registry.list_fields()
        assert "field1" in fields
        assert "field2" in fields

        types = registry.list_field_types()
        assert "type1" in types

    def test_registry_metadata(self) -> None:
        """Test registry metadata functionality."""
        registry = FlextFields.Registry.FieldRegistry()
        field = FlextFields.Core.StringField("test", description="Test field")

        registry.register_field(
            "test",
            cast("FlextFields.Core.BaseField[object]", field),
        )

        result = registry.get_field_metadata("test")
        assert result.success
        assert result.unwrap()["name"] == "test"
        assert result.unwrap()["description"] == "Test field"

    def test_registry_clear(self) -> None:
        """Test registry clear functionality."""
        registry = FlextFields.Registry.FieldRegistry()
        field = FlextFields.Core.StringField("test")

        registry.register_field(
            "test",
            cast("FlextFields.Core.BaseField[object]", field),
        )
        registry.register_field_type(
            "custom",
            cast(
                "type[FlextFields.Core.BaseField[object]]",
                FlextFields.Core.StringField,
            ),
        )

        assert len(registry.list_fields()) > 0
        assert len(registry.list_field_types()) > 0

        registry.clear()

        assert len(registry.list_fields()) == 0
        assert len(registry.list_field_types()) == 0


class TestFlextFieldsSchema:
    """Test FlextFields.Schema functionality."""

    def test_field_processor_basic(self) -> None:
        """Test basic FieldProcessor operations."""
        processor = FlextFields.Schema.FieldProcessor()
        schema = {
            "fields": [
                {
                    "name": "username",
                    "type": "string",
                    "required": True,
                    "constraints": {"min_length": 3},
                },
            ],
            "metadata": {"version": "1.0"},
        }

        result = processor.process_field_schema(cast("FlextTypes.Core.Dict", schema))
        assert result.success
        assert len(cast("FlextTypes.Core.List", result.unwrap()["fields"])) == 1

    def test_field_processor_validation(self) -> None:
        """Test FieldProcessor validation."""
        processor = FlextFields.Schema.FieldProcessor()

        # Missing required keys
        invalid_schema = {
            "fields": [
                {"name": "test"},  # Missing "type"
            ],
        }

        result = processor.process_field_schema(
            cast("FlextTypes.Core.Dict", invalid_schema)
        )
        assert result.success  # Should still succeed but with empty fields

    def test_process_multiple_schemas(self) -> None:
        """Test processing multiple schemas."""
        processor = FlextFields.Schema.FieldProcessor()
        schemas = [
            {"fields": [{"name": "field1", "type": "string"}], "metadata": {}},
            {"fields": [{"name": "field2", "type": "integer"}], "metadata": {}},
        ]

        result = processor.process_multiple_fields_schema(
            cast("list[FlextTypes.Core.Dict]", schemas)
        )
        assert result.success
        assert len(result.unwrap()) == 2


class TestFlextFieldsFactory:
    """Test FlextFields.Factory functionality."""

    def test_create_field_basic(self) -> None:
        """Test basic field creation."""
        result = FlextFields.Factory.create_field("string", "test_field")
        assert result.success
        assert isinstance(result.unwrap(), FlextFields.Core.StringField)

        result = FlextFields.Factory.create_field("integer", "int_field")
        assert result.success
        assert isinstance(result.unwrap(), FlextFields.Core.IntegerField)

        result = FlextFields.Factory.create_field("boolean", "bool_field")
        assert result.success
        assert isinstance(result.unwrap(), FlextFields.Core.BooleanField)

    def test_create_field_with_config(self) -> None:
        """Test field creation with configuration."""
        result = FlextFields.Factory.create_field(
            "string",
            "configured_field",
            min_length=5,
            max_length=20,
            required=False,
            description="Configured field",
        )
        assert result.success
        field = cast("FlextFields.Core.BaseField[object]", result.unwrap())
        assert field.name == "configured_field"
        assert field.required is False

    def test_create_unknown_field_type(self) -> None:
        """Test creating unknown field type."""
        result = FlextFields.Factory.create_field("unknown", "test")
        assert result.failure
        assert "Unknown field type" in (result.error or "")

    def test_create_fields_from_schema(self) -> None:
        """Test creating fields from schema."""
        schema = {
            "fields": [
                {
                    "name": "username",
                    "type": "string",
                    "min_length": 3,
                    "required": True,
                },
                {
                    "name": "age",
                    "type": "integer",
                    "min_value": 0,
                    "required": False,
                    "default": 0,
                },
            ],
        }

        result = FlextFields.Factory.create_fields_from_schema(
            cast("FlextTypes.Core.Dict", schema)
        )
        assert result.success
        assert len(result.unwrap()) == 2
        assert result.unwrap()[0].name == "username"
        assert result.unwrap()[1].name == "age"

    def test_create_fields_from_invalid_schema(self) -> None:
        """Test creating fields from invalid schema."""
        # Missing fields key
        result = FlextFields.Factory.create_fields_from_schema({})
        assert result.failure

        # Invalid fields structure
        schema = {"fields": "not_a_list"}
        result = FlextFields.Factory.create_fields_from_schema(
            cast("FlextTypes.Core.Dict", schema)
        )
        assert result.failure

    def test_field_builder(self) -> None:
        """Test FieldBuilder pattern."""
        builder = FlextFields.Factory.FieldBuilder("string", "test_field")

        result = (
            builder.with_required(required=False)
            .with_default("default_value")
            .with_description("Test field")
            .with_length(min_length=2, max_length=50)
            .with_pattern(r"^[a-zA-Z]+$")
            .build()
        )

        assert result.success
        field = cast("FlextFields.Core.BaseField[object]", result.unwrap())
        assert field.name == "test_field"
        assert field.required is False

    def test_field_builder_numeric(self) -> None:
        """Test FieldBuilder with numeric field."""
        builder = FlextFields.Factory.FieldBuilder("integer", "number_field")

        result = builder.with_range(min_value=1, max_value=100).with_default(50).build()

        assert result.success


class TestFlextFieldsMetadata:
    """Test FlextFields.Metadata functionality."""

    def test_analyze_field(self) -> None:
        """Test field analysis."""
        field = FlextFields.Core.StringField(
            "test_field",
            min_length=3,
            max_length=20,
            pattern=r"^[a-z]+$",
            description="Test field",
        )

        result = FlextFields.Metadata.analyze_field(
            cast("FlextFields.Core.BaseField[object]", field)
        )
        assert result.success

        analysis = result.unwrap()
        assert analysis["field_class"] == "StringField"
        assert "string_constraints" in analysis
        a_dict = analysis
        sc = cast("FlextTypes.Core.Dict", a_dict["string_constraints"])
        assert cast("int", sc["min_length"]) == 3
        assert cast("int", sc["max_length"]) == 20

    def test_analyze_numeric_field(self) -> None:
        """Test analysis of numeric field."""
        field = FlextFields.Core.IntegerField("int_field", min_value=0, max_value=100)

        result = FlextFields.Metadata.analyze_field(
            cast("FlextFields.Core.BaseField[object]", field)
        )
        assert result.success

        analysis = result.unwrap()
        assert "numeric_constraints" in analysis
        a2 = analysis
        nc = cast("FlextTypes.Core.Dict", a2["numeric_constraints"])
        assert cast("int", nc["min_value"]) == 0
        assert cast("int", nc["max_value"]) == 100

    def test_get_field_summary(self) -> None:
        """Test field summary generation."""
        fields = [
            cast(
                "FlextFields.Core.BaseField[object]",
                FlextFields.Core.StringField("name", required=True),
            ),
            cast(
                "FlextFields.Core.BaseField[object]",
                FlextFields.Core.IntegerField("age", required=True, default=0),
            ),
            cast(
                "FlextFields.Core.BaseField[object]",
                FlextFields.Core.BooleanField("active", required=False, default=True),
            ),
            cast(
                "FlextFields.Core.BaseField[object] ",
                FlextFields.Core.EmailField("email", required=True),
            ),
        ]

        result = FlextFields.Metadata.get_field_summary(fields)
        assert result.success

        summary = result.unwrap()
        assert summary["total_fields"] == 4
        assert summary["required_fields"] == 3
        assert summary["optional_fields"] == 1
        assert summary["fields_with_defaults"] == 2
        field_types = cast("FlextTypes.Core.StringList", summary["field_types"])
        assert "string" in field_types
        assert "integer" in field_types


class TestFlextFieldsConfiguration:
    """Test FlextFields configuration functionality."""

    def test_configure_fields_system(self) -> None:
        """Test fields system configuration."""
        config: FlextTypes.Config.ConfigDict = {
            "environment": "development",
            "log_level": "DEBUG",
            "validation_level": "strict",
            "enable_field_validation": True,
        }

        result = FlextConfig.create(constants=config)
        assert result.success
        validated_config = result.unwrap()
        assert validated_config.environment == "development"
        assert validated_config.log_level == "DEBUG"
        assert validated_config["enable_field_validation"] is True

    def test_configure_invalid_environment(self) -> None:
        """Test configuration with invalid environment."""
        config: FlextTypes.Config.ConfigDict = {"environment": "invalid_env"}

        result = FlextConfig.create(constants=config)
        assert result.failure
        err = result.error or ""
        assert "Invalid environment" in err

    def test_get_fields_system_config(self) -> None:
        """Test getting current fields system configuration."""
        result = FlextConfig.create()
        assert result.success

        config = result.unwrap()
        config_dict = config.to_dict()
        assert "environment" in config_dict
        assert "app_name" in config_dict
        assert "version" in config_dict
        # Test that we can access validation functionality
        assert hasattr(FlextValidations.FieldValidators, "validate_email")
        assert hasattr(FlextValidations.FieldValidators, "validate_uuid")

    def test_create_environment_fields_config(self) -> None:
        """Test creating environment-specific configuration."""
        result = FlextConfig.create(constants={"environment": "production"})
        assert result.success
        config = result.unwrap()
        assert config.environment == "production"
        assert config.log_level == "DEBUG"  # test environment uses DEBUG

        result = FlextConfig.create(constants={"environment": "development"})
        assert result.success
        config = result.unwrap()
        assert config.environment == "development"
        assert config.log_level == "DEBUG"

        # Invalid environment
        result = FlextConfig.create(constants={"environment": "invalid"})
        assert result.failure

    def test_optimize_fields_performance(self) -> None:
        """Test fields performance optimization."""
        # Method not implemented
        # result = FlextFields.optimize_fields_performance(config)
        # assert result.success

        # optimized = result.unwrap()
        # assert optimized["performance_level"] == "high"
        # assert optimized["enable_field_caching"] is True
        # assert optimized["cache_validation_results"] is True

        # Low performance (method not implemented)
        # config = cast("FlextTypes.Config.ConfigDict", {"performance_level": "low"})
        # result = FlextFields.optimize_fields_performance(config)
        # assert result.success
        # optimized = result.unwrap()
        # assert optimized["enable_field_caching"] is False


class TestFlextFieldsLegacyCompatibility:
    """Test legacy compatibility functions."""

    def test_create_string_field_legacy(self) -> None:
        """Test legacy string field creation."""
        # Method not implemented
        # result = FlextFields.create_string_field(
        #     name="test_field",
        #     required=True,
        #     min_length=3,
        #     description="Test field",
        # )
        # assert result.success
        # field = cast("FlextFields.Core.BaseField[str]", result.unwrap())
        # assert field.name == "test_field"

    def test_create_integer_field_legacy(self) -> None:
        """Test legacy integer field creation."""
        field = FlextFields.Core.IntegerField(
            "int_field",
            min_value=0,
            default=10,
        )
        assert field.default == 10
        assert field.name == "int_field"

    def test_create_boolean_field_legacy(self) -> None:
        """Test legacy boolean field creation."""
        field = FlextFields.Core.BooleanField("bool_field", default=True)
        assert field.default is True
        assert field.name == "bool_field"


class TestFlextFieldsEdgeCases:
    """Test edge cases and error conditions."""

    def test_field_with_none_values(self) -> None:
        """Test field behavior with None values."""
        field = FlextFields.Core.StringField("test", required=False, default="default")

        result = field.validate(None)
        assert result.success
        assert result.unwrap() == "default"

    def test_field_validation_errors(self) -> None:
        """Test various validation error conditions."""
        string_field = FlextFields.Core.StringField("test")

        # Non-string input
        result = string_field.validate(123)
        assert result.failure
        err2 = result.error or ""
        assert FlextConstants.Messages.TYPE_MISMATCH in err2

        # Test integer field with boolean
        int_field = FlextFields.Core.IntegerField("test")
        int_result = int_field.validate(True)
        assert int_result.failure

    @given(st.text(min_size=1, max_size=50))
    def test_string_field_with_random_input(self, text: str) -> None:
        """Property-based test for string field."""
        field = FlextFields.Core.StringField("test", min_length=1, max_length=100)

        result = field.validate(text)
        if len(text) <= 100:
            assert result.success
            assert result.unwrap() == text
        else:
            assert result.failure

    @given(st.integers())
    def test_integer_field_with_random_input(self, value: int) -> None:
        """Property-based test for integer field."""
        field = FlextFields.Core.IntegerField("test")

        result = field.validate(value)
        assert result.success
        assert result.unwrap() == value

    def test_datetime_field_edge_cases(self) -> None:
        """Test datetime field edge cases."""
        field = FlextFields.Core.DateTimeField("test", required=False)

        # None value
        result = field.validate(None)
        assert result.success
        assert isinstance(result.unwrap(), datetime)

        # Invalid type
        result = field.validate(123)
        assert result.failure


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
