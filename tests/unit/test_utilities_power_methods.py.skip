"""Comprehensive edge case tests for u power methods.

Tests all 9 power methods with 200+ edge cases using flext_tests infrastructure:
- validate() - Declarative validation with DSL/Builder
- parse() - Universal type parsing
- transform() - Data transformation
- pipe() - Functional pipeline
- merge() - Deep dictionary merging
- extract() - Path-based extraction
- generate() - Unified ID generation
- batch() - Batch processing
- retry() - Retry with backoff

Copyright (c) 2025 FLEXT Team. All rights reserved.
SPDX-License-Identifier: MIT
"""

from __future__ import annotations

import math
import operator
import time
from collections.abc import Callable, Mapping
from enum import StrEnum
from typing import ClassVar

import pytest
from pydantic import BaseModel

from flext_core import FlextResult, t, u
from flext_tests import tm

# ValidatorDSL (V namespace) not exposed in current FlextUtilities architecture
pytestmark = pytest.mark.skip(reason="ValidatorDSL not available in FlextUtilities")

# Alias for V namespace - ValidatorDSL not exposed in FlextUtilities
# V = u.V


# =============================================================================
# TEST FIXTURES - Models and Enums for testing
# =============================================================================


class Status(StrEnum):
    """Test enum for parse() tests."""

    ACTIVE = "active"
    INACTIVE = "inactive"
    PENDING = "pending"


class UserModel(BaseModel):
    """Test Pydantic model for parse/transform tests."""

    name: str
    email: str
    age: int = 0


class AddressModel(BaseModel):
    """Nested model for complex tests."""

    city: str
    country: str = "US"


# =============================================================================
# CENTRALIZED TEST SCENARIOS - Using ClassVar pattern from test_utilities.py
# =============================================================================


class PowerMethodScenarios:
    """Centralized test scenarios for power methods."""

    # -------------------------------------------------------------------------
    # validate() scenarios
    # -------------------------------------------------------------------------

    VALIDATE_SINGLE_PASS: ClassVar[
        list[tuple[str, object, Callable[[object], bool]]]
    ] = [
        ("non_empty_string", "hello", V.string.non_empty),
        ("valid_email", "test@example.com", V.string.email),
        ("positive_number", 42, V.number.positive),
        ("non_empty_list", [1, 2, 3], V.collection.non_empty),
        ("valid_dict", {"a": 1}, V.dict.non_empty),
    ]

    VALIDATE_SINGLE_FAIL: ClassVar[
        list[tuple[str, object, Callable[[object], bool], str]]
    ] = [
        ("empty_string", "", V.string.non_empty, "non_empty"),
        ("whitespace_only", "   ", V.string.non_empty, "non_empty"),
        ("invalid_email", "not-email", V.string.email, "email"),
        ("negative_number", -5, V.number.positive, "positive"),
        ("empty_list", [], V.collection.non_empty, "non_empty"),
    ]

    VALIDATE_MODE_ANY: ClassVar[list[tuple[str, object, bool]]] = [
        ("email_passes", "test@example.com", True),
        ("url_passes", "https://example.com", True),
        ("neither_passes", "just-text", False),
    ]

    # -------------------------------------------------------------------------
    # V.string validators scenarios
    # -------------------------------------------------------------------------

    STRING_NON_EMPTY: ClassVar[list[tuple[str, object, bool]]] = [
        ("valid_string", "hello", True),
        ("empty_string", "", False),
        ("whitespace_only", "   ", False),
        ("non_string_int", 123, False),
        ("non_string_none", None, False),
    ]

    STRING_LENGTH: ClassVar[list[tuple[str, str, int, int, bool]]] = [
        ("within_range", "hello", 3, 10, True),
        ("at_min", "hello", 5, 10, True),
        ("at_max", "hello", 1, 5, True),
        ("below_min", "hi", 5, 10, False),
        ("above_max", "hello world", 1, 5, False),
    ]

    STRING_PATTERNS: ClassVar[list[tuple[str, str, str, bool]]] = [
        ("lowercase_match", "hello", r"^[a-z]+$", True),
        ("uppercase_fail", "Hello", r"^[a-z]+$", False),
        ("alphanumeric", "abc123", r"^[a-z0-9]+$", True),
    ]

    STRING_FORMAT: ClassVar[list[tuple[str, str, str, bool]]] = [
        ("valid_email", "test@example.com", "email", True),
        ("invalid_email", "not-email", "email", False),
        ("valid_url_http", "http://example.com", "url", True),
        ("valid_url_https", "https://example.com/path", "url", True),
        ("invalid_url", "not-a-url", "url", False),
    ]

    # -------------------------------------------------------------------------
    # V.number validators scenarios
    # -------------------------------------------------------------------------

    NUMBER_SIGN: ClassVar[list[tuple[str, object, str, bool]]] = [
        ("positive_int", 42, "positive", True),
        ("positive_float", math.pi, "positive", True),
        ("zero_positive", 0, "positive", False),
        ("negative_positive", -5, "positive", False),
        ("negative_int", -10, "negative", True),
        ("zero_negative", 0, "negative", False),
        ("positive_negative", 5, "negative", False),
        ("zero_check", 0, "zero", True),
        ("non_zero_check", 5, "zero", False),
    ]

    NUMBER_RANGE: ClassVar[list[tuple[str, float, float, float, bool]]] = [
        ("within_range", 50, 0, 100, True),
        ("at_min", 0, 0, 100, True),
        ("at_max", 100, 0, 100, True),
        ("below_min", -1, 0, 100, False),
        ("above_max", 101, 0, 100, False),
    ]

    # -------------------------------------------------------------------------
    # V.collection validators scenarios
    # -------------------------------------------------------------------------

    COLLECTION_NON_EMPTY: ClassVar[list[tuple[str, object, bool]]] = [
        ("non_empty_list", [1, 2, 3], True),
        ("empty_list", [], False),
        ("non_empty_dict", {"a": 1}, True),
        ("empty_dict", {}, False),
        ("non_empty_set", {1, 2}, True),
        ("empty_set", set(), False),
        ("non_empty_tuple", (1, 2), True),
        ("empty_tuple", (), False),
    ]

    # -------------------------------------------------------------------------
    # parse() scenarios
    # -------------------------------------------------------------------------

    PARSE_PRIMITIVES: ClassVar[list[tuple[str, object, type, object]]] = [
        ("str_to_int", "42", int, 42),
        ("int_to_str", 42, str, "42"),
        ("str_to_float", "1.5", float, 1.5),
        ("int_to_float", 42, float, 42.0),
        ("str_true", "true", bool, True),
        ("str_false", "false", bool, False),
        ("str_yes", "yes", bool, True),
        ("str_no", "no", bool, False),
    ]

    PARSE_ENUM: ClassVar[list[tuple[str, str, bool, object]]] = [
        ("exact_match", "active", False, Status.ACTIVE),
        ("case_insensitive_upper", "ACTIVE", True, Status.ACTIVE),
        ("case_insensitive_mixed", "Active", True, Status.ACTIVE),
    ]

    # -------------------------------------------------------------------------
    # transform() scenarios
    # -------------------------------------------------------------------------

    TRANSFORM_STRIP: ClassVar[
        list[
            tuple[
                str,
                Mapping[str, t.GeneralValueType],
                bool,
                bool,
                Mapping[str, t.GeneralValueType],
            ]
        ]
    ] = [
        ("strip_none", {"a": 1, "b": None, "c": 3}, True, False, {"a": 1, "c": 3}),
        ("strip_empty", {"a": 1, "b": "", "c": []}, False, True, {"a": 1}),
        ("strip_both", {"a": 1, "b": None, "c": ""}, True, True, {"a": 1}),
        ("no_strip", {"a": 1, "b": None}, False, False, {"a": 1, "b": None}),
    ]

    TRANSFORM_KEYS: ClassVar[
        list[
            tuple[
                str,
                Mapping[str, t.GeneralValueType],
                Mapping[str, str],
                Mapping[str, t.GeneralValueType],
            ]
        ]
    ] = [
        ("rename_single", {"old": 1}, {"old": "new"}, {"new": 1}),
        ("rename_multiple", {"a": 1, "b": 2}, {"a": "x", "b": "y"}, {"x": 1, "y": 2}),
        ("partial_rename", {"a": 1, "b": 2}, {"a": "x"}, {"x": 1, "b": 2}),
    ]

    # -------------------------------------------------------------------------
    # merge() scenarios
    # -------------------------------------------------------------------------

    MERGE_STRATEGY: ClassVar[
        list[
            tuple[
                str,
                Mapping[str, t.GeneralValueType],
                Mapping[str, t.GeneralValueType],
                str,
                Mapping[str, t.GeneralValueType],
            ]
        ]
    ] = [
        ("override_flat", {"a": 1}, {"a": 2}, "override", {"a": 2}),
        (
            "deep_nested",
            {"a": {"x": 1}},
            {"a": {"y": 2}},
            "deep",
            {"a": {"x": 1, "y": 2}},
        ),
        ("append_lists", {"a": [1]}, {"a": [2]}, "append", {"a": [1, 2]}),
    ]

    # -------------------------------------------------------------------------
    # extract() scenarios
    # -------------------------------------------------------------------------

    EXTRACT_PATH: ClassVar[
        list[
            tuple[
                str,
                Mapping[str, t.GeneralValueType],
                str,
                t.GeneralValueType,
            ]
        ]
    ] = [
        ("simple_key", {"name": "John"}, "name", "John"),
        ("nested_path", {"user": {"name": "John"}}, "user.name", "John"),
        ("deep_nested", {"a": {"b": {"c": 1}}}, "a.b.c", 1),
    ]

    EXTRACT_ARRAY: ClassVar[
        list[
            tuple[
                str,
                Mapping[str, t.GeneralValueType],
                str,
                t.GeneralValueType,
            ]
        ]
    ] = [
        ("first_item", {"items": [1, 2, 3]}, "items[0]", 1),
        ("last_item", {"items": [1, 2, 3]}, "items[-1]", 3),
        ("nested_array", {"data": {"items": ["a", "b"]}}, "data.items[0]", "a"),
    ]

    # -------------------------------------------------------------------------
    # generate() scenarios
    # -------------------------------------------------------------------------

    GENERATE_KINDS: ClassVar[list[tuple[str, str, str]]] = [
        ("id_default", "id", ""),
        ("uuid_full", "uuid", ""),
        ("correlation", "correlation", "corr"),
        ("entity", "entity", "ent"),
        ("batch", "batch", "batch"),
        ("transaction", "transaction", "txn"),
        ("event", "event", "evt"),
        ("command", "command", "cmd"),
        ("query", "query", "qry"),
    ]


# =============================================================================
# TEST CLASS: validate() POWER METHOD
# =============================================================================


class TestValidateMethod:
    """Tests for u.validate() power method."""

    def test_validate_no_validators_returns_ok(self) -> None:
        """Empty validators list returns Ok with original value."""
        result = u.Validation.validate("hello")
        tm.ok(result)
        assert result.value == "hello"

    @pytest.mark.parametrize(
        ("description", "value", "validator"),
        PowerMethodScenarios.VALIDATE_SINGLE_PASS,
    )
    def test_validate_single_pass(
        self,
        description: str,
        value: object,
        validator: Callable[[object], bool],
    ) -> None:
        """Single passing validator returns Ok."""
        # Business Rule: validate accepts ValidatorSpec, wrap Callable[[object], bool] in Validator
        # Implication: Validator wrapper makes callable compatible with ValidatorSpec protocol
        validator_spec = u.V.custom(predicate=validator, description=description)
        result = u.Validation.validate(value, validator_spec)
        tm.ok(result, msg=f"{description} should pass")
        assert result.value == value

    @pytest.mark.parametrize(
        ("description", "value", "validator", "error_contains"),
        PowerMethodScenarios.VALIDATE_SINGLE_FAIL,
    )
    def test_validate_single_fail(
        self,
        description: str,
        value: object,
        validator: Callable[[object], bool],
        error_contains: str,
    ) -> None:
        """Single failing validator returns Fail."""
        # Business Rule: validate accepts ValidatorSpec, wrap Callable[[object], bool] in Validator
        # Implication: Validator wrapper makes callable compatible with ValidatorSpec protocol
        validator_spec = u.V.custom(predicate=validator, description=description)
        result = u.Validation.validate(value, validator_spec)
        error = tm.fail(result)
        assert error_contains in error, (
            f"{description}: expected '{error_contains}' in error"
        )

    def test_validate_multiple_all_pass(self) -> None:
        """All validators pass returns Ok."""
        result = u.Validation.validate(
            "hello@test.com",
            V.string.non_empty,
            V.string.email,
        )
        tm.ok(result)

    def test_validate_multiple_first_fails(self) -> None:
        """First validator fails returns Fail (fail_fast)."""
        result = u.Validation.validate(
            "",
            V.string.non_empty,
            V.string.email,
        )
        error = tm.fail(result)
        assert "non_empty" in error

    def test_validate_collect_errors(self) -> None:
        """collect_errors=True gathers all errors."""
        result = u.Validation.validate(
            "",
            V.string.non_empty,
            V.string.min_length(5),
            fail_fast=True,
            collect_errors=True,
        )
        error = tm.fail(result)
        assert "non_empty" in error
        assert "min_length" in error

    @pytest.mark.parametrize(
        ("description", "value", "expected_success"),
        PowerMethodScenarios.VALIDATE_MODE_ANY,
    )
    def test_validate_mode_any(
        self,
        description: str,
        value: object,
        expected_success: bool,
    ) -> None:
        """mode='any' validation tests."""
        result = u.Validation.validate(
            value,
            V.string.email,
            V.string.url,
            mode="any",
        )
        if expected_success:
            tm.ok(result, msg=f"{description} should pass")
        else:
            tm.fail(result)

    def test_validate_with_field_name(self) -> None:
        """field_name adds context to error message."""
        result = u.Validation.validate(
            "",
            V.string.non_empty,
            field_name="user.email",
        )
        error = tm.fail(result)
        assert "user.email:" in error

    def test_validate_and_operator(self) -> None:
        """AND operator composition."""
        validator = V.string.non_empty & V.string.max_length(10)
        result = u.Validation.validate("hello", validator)
        tm.ok(result)

    def test_validate_or_operator(self) -> None:
        """OR operator composition."""
        validator = V.string.email | V.string.url
        result = u.Validation.validate("test@example.com", validator)
        tm.ok(result)

    def test_validate_not_operator(self) -> None:
        """NOT operator negates validator."""
        validator = ~V.string.non_empty
        result = u.Validation.validate("", validator)
        tm.ok(result)

    def test_validate_complex_expression(self) -> None:
        """Complex expression with multiple operators."""
        validator = (
            V.string.non_empty
            & V.string.min_length(3)
            & (V.string.email | V.string.url)
        )
        result = u.Validation.validate("test@example.com", validator)
        tm.ok(result)


# =============================================================================
# TEST CLASS: V.string VALIDATORS
# =============================================================================


class TestStringValidators:
    """Tests for V.string validators using parametrized scenarios."""

    @pytest.mark.parametrize(
        ("description", "value", "expected"),
        PowerMethodScenarios.STRING_NON_EMPTY,
    )
    def test_string_non_empty(
        self,
        description: str,
        value: object,
        expected: bool,
    ) -> None:
        """Test string.non_empty validator."""
        result = V.string.non_empty(value)
        assert result is expected, f"{description}: expected {expected}"

    @pytest.mark.parametrize(
        ("description", "value", "min_len", "max_len", "expected"),
        PowerMethodScenarios.STRING_LENGTH,
    )
    def test_string_length(
        self,
        description: str,
        value: str,
        min_len: int,
        max_len: int,
        expected: bool,
    ) -> None:
        """Test string.length validator."""
        result = V.string.length(min_len, max_len)(value)
        assert result is expected, f"{description}: expected {expected}"

    @pytest.mark.parametrize(
        ("description", "value", "pattern", "expected"),
        PowerMethodScenarios.STRING_PATTERNS,
    )
    def test_string_matches(
        self,
        description: str,
        value: str,
        pattern: str,
        expected: bool,
    ) -> None:
        """Test string.matches validator."""
        result = V.string.matches(pattern)(value)
        assert result is expected, f"{description}: expected {expected}"

    @pytest.mark.parametrize(
        ("description", "value", "format_type", "expected"),
        PowerMethodScenarios.STRING_FORMAT,
    )
    def test_string_format(
        self,
        description: str,
        value: str,
        format_type: str,
        expected: bool,
    ) -> None:
        """Test string format validators."""
        validator = getattr(V.string, format_type)
        result = validator(value)
        assert result is expected, f"{description}: expected {expected}"

    def test_string_contains(self) -> None:
        """Test string.contains validator."""
        assert V.string.contains("ell")("hello") is True
        assert V.string.contains("xyz")("hello") is False

    def test_string_starts_with(self) -> None:
        """Test string.starts_with validator."""
        assert V.string.starts_with("hel")("hello") is True
        assert V.string.starts_with("xyz")("hello") is False

    def test_string_ends_with(self) -> None:
        """Test string.ends_with validator."""
        assert V.string.ends_with("lo")("hello") is True
        assert V.string.ends_with("xyz")("hello") is False


# =============================================================================
# TEST CLASS: V.number VALIDATORS
# =============================================================================


class TestNumberValidators:
    """Tests for V.number validators using parametrized scenarios."""

    @pytest.mark.parametrize(
        ("description", "value", "validator_name", "expected"),
        PowerMethodScenarios.NUMBER_SIGN,
    )
    def test_number_sign(
        self,
        description: str,
        value: object,
        validator_name: str,
        expected: bool,
    ) -> None:
        """Test number sign validators."""
        validator = getattr(V.number, validator_name)
        result = validator(value)
        assert result is expected, f"{description}: expected {expected}"

    @pytest.mark.parametrize(
        ("description", "value", "min_val", "max_val", "expected"),
        PowerMethodScenarios.NUMBER_RANGE,
    )
    def test_number_in_range(
        self,
        description: str,
        value: float,
        min_val: float,
        max_val: float,
        expected: bool,
    ) -> None:
        """Test number.in_range validator."""
        result = V.number.in_range(min_val, max_val)(value)
        assert result is expected, f"{description}: expected {expected}"

    def test_number_integer(self) -> None:
        """Test number.integer validator."""
        assert V.number.integer(42) is True
        assert V.number.integer(42.0) is True
        assert V.number.integer(42.5) is False

    def test_number_greater_than(self) -> None:
        """Test number.greater_than validator."""
        assert V.number.greater_than(5)(10) is True
        assert V.number.greater_than(5)(5) is False
        assert V.number.greater_than(5)(3) is False

    def test_number_less_than(self) -> None:
        """Test number.less_than validator."""
        assert V.number.less_than(10)(5) is True
        assert V.number.less_than(10)(10) is False
        assert V.number.less_than(10)(15) is False


# =============================================================================
# TEST CLASS: V.collection VALIDATORS
# =============================================================================


class TestCollectionValidators:
    """Tests for V.collection validators using parametrized scenarios."""

    @pytest.mark.parametrize(
        ("description", "value", "expected"),
        PowerMethodScenarios.COLLECTION_NON_EMPTY,
    )
    def test_collection_non_empty(
        self,
        description: str,
        value: object,
        expected: bool,
    ) -> None:
        """Test collection.non_empty validator."""
        result = V.collection.non_empty(value)
        assert result is expected, f"{description}: expected {expected}"

    def test_collection_length(self) -> None:
        """Test collection.length validator."""
        assert V.collection.length(3)([1, 2, 3]) is True
        assert V.collection.length(3)([1, 2]) is False

    def test_collection_min_length(self) -> None:
        """Test collection.min_length validator."""
        assert V.collection.min_length(2)([1, 2, 3]) is True
        assert V.collection.min_length(5)([1, 2]) is False

    def test_collection_max_length(self) -> None:
        """Test collection.max_length validator."""
        assert V.collection.max_length(5)([1, 2, 3]) is True
        assert V.collection.max_length(2)([1, 2, 3]) is False

    def test_collection_contains(self) -> None:
        """Test collection.contains validator."""
        assert V.collection.contains(2)([1, 2, 3]) is True
        assert V.collection.contains(5)([1, 2, 3]) is False

    def test_collection_all_match(self) -> None:
        """Test collection.all_match validator."""
        assert V.collection.all_match(V.number.positive)([1, 2, 3]) is True
        assert V.collection.all_match(V.number.positive)([1, -2, 3]) is False

    def test_collection_any_match(self) -> None:
        """Test collection.any_match validator."""
        assert V.collection.any_match(V.number.negative)([1, -2, 3]) is True
        assert V.collection.any_match(V.number.negative)([1, 2, 3]) is False


# =============================================================================
# TEST CLASS: V.dict VALIDATORS
# =============================================================================


class TestDictValidators:
    """Tests for V.dict validators."""

    def test_dict_non_empty(self) -> None:
        """Test dict.non_empty validator."""
        assert V.dict.non_empty({"a": 1}) is True
        assert V.dict.non_empty({}) is False

    def test_dict_has_key(self) -> None:
        """Test dict.has_key validator."""
        assert V.dict.has_key("a")({"a": 1, "b": 2}) is True
        assert V.dict.has_key("c")({"a": 1, "b": 2}) is False

    def test_dict_has_keys(self) -> None:
        """Test dict.has_keys validator."""
        assert V.dict.has_keys("a", "b")({"a": 1, "b": 2}) is True
        assert V.dict.has_keys("a", "c")({"a": 1, "b": 2}) is False

    def test_dict_key_matches(self) -> None:
        """Test dict.key_matches validator."""
        assert V.dict.key_matches("age", V.number.positive)({"age": 25}) is True
        assert V.dict.key_matches("age", V.number.positive)({"age": -5}) is False

    def test_dict_all_values_match(self) -> None:
        """Test dict.all_values_match validator."""
        assert V.dict.all_values_match(V.number.positive)({"a": 1, "b": 2}) is True
        assert V.dict.all_values_match(V.number.positive)({"a": 1, "b": -2}) is False


# =============================================================================
# TEST CLASS: parse() POWER METHOD
# =============================================================================


class TestParseMethod:
    """Tests for u.parse() power method."""

    @pytest.mark.parametrize(
        ("description", "value", "target_type", "expected"),
        PowerMethodScenarios.PARSE_PRIMITIVES,
    )
    def test_parse_primitives(
        self,
        description: str,
        value: object,
        target_type: type,
        expected: object,
    ) -> None:
        """Test parsing primitive types."""
        # Use type narrowing - parse() returns FlextResult[T] where T is target_type
        result = u.parse(value, target_type)
        # Type narrowing: result is FlextResult[target_type] after successful parse
        parsed = tm.ok(result, msg=f"{description} failed")
        assert parsed == expected, f"{description}: got {parsed}, expected {expected}"

    @pytest.mark.parametrize(
        ("description", "value", "case_insensitive", "expected_member"),
        PowerMethodScenarios.PARSE_ENUM,
    )
    def test_parse_enum(
        self,
        description: str,
        value: str,
        case_insensitive: bool,
        expected_member: Status,
    ) -> None:
        """Test parsing enum values."""
        # Use type narrowing - parse() returns FlextResult[T] where T is Status
        result = u.parse(
            value,
            Status,
            case_insensitive=case_insensitive,
        )
        # Type narrowing: result is FlextResult[Status] after successful parse
        parsed: Status = tm.ok(result, msg=f"{description} failed")
        assert parsed == expected_member, f"{description}"

    def test_parse_enum_case_insensitive(self) -> None:
        """Test case-insensitive enum parsing."""
        result = u.parse("active", Status, case_insensitive=True)
        parsed = tm.ok(result)
        assert parsed == Status.ACTIVE

    def test_parse_enum_invalid_fails(self) -> None:
        """Test that invalid enum value fails."""
        result = u.parse("invalid", Status)
        tm.fail(result)

    def test_parse_with_default(self) -> None:
        """Test parsing with default value on failure."""
        result = u.parse("not_a_number", int, default=42)
        parsed = tm.ok(result)
        assert parsed == 42

    def test_parse_with_default_factory(self) -> None:
        """Test parsing with default factory on failure."""
        result = u.parse("invalid", int, default_factory=lambda: 99)
        parsed = tm.ok(result)
        assert parsed == 99

    def test_parse_str_to_int_coerce(self) -> None:
        """Test string to int coercion."""
        result = u.parse("123", int, coerce=True)
        parsed = tm.ok(result)
        assert parsed == 123
        assert isinstance(parsed, int)

    def test_parse_int_to_str_coerce(self) -> None:
        """Test int to string coercion."""
        result = u.parse(456, str, coerce=True)
        parsed = tm.ok(result)
        assert parsed == "456"
        assert isinstance(parsed, str)

    def test_parse_float_to_int_coerce(self) -> None:
        """Test float to int coercion."""
        result = u.parse(math.pi, int, coerce=True)
        parsed = tm.ok(result)
        assert parsed == 3
        assert isinstance(parsed, int)

    def test_parse_strict_mode_allows_direct_coercion(self) -> None:
        """Test strict mode still allows direct target(value) coercion."""
        # strict=True only skips primitive coercion helpers like _coerce_primitive
        # but int("123") works directly via target(value) fallback
        result = u.parse("123", int, strict=True)
        parsed = tm.ok(result)
        assert parsed == 123

    def test_parse_strict_mode_passes_on_exact_type(self) -> None:
        """Test strict mode accepts exact type match."""
        result = u.parse(123, int, strict=True)
        parsed = tm.ok(result)
        assert parsed == 123

    def test_parse_bool_values(self) -> None:
        """Test parsing boolean values."""
        result_true = u.parse(True, bool)
        result_false = u.parse(False, bool)
        assert tm.ok(result_true) is True
        assert tm.ok(result_false) is False

    def test_parse_none_with_default(self) -> None:
        """Test parsing None with default value."""
        result = u.parse(None, int, default=0)
        parsed = tm.ok(result)
        assert parsed == 0


# =============================================================================
# TEST CLASS: transform() POWER METHOD
# =============================================================================


class TestTransformMethod:
    """Tests for u.transform() power method."""

    @pytest.mark.parametrize(
        ("description", "input_dict", "strip_none", "strip_empty", "expected"),
        PowerMethodScenarios.TRANSFORM_STRIP,
    )
    def test_transform_strip_options(
        self,
        description: str,
        input_dict: Mapping[str, t.GeneralValueType],
        strip_none: bool,
        strip_empty: bool,
        expected: Mapping[str, t.GeneralValueType],
    ) -> None:
        """Test transform with strip_none and strip_empty options."""
        result = u.transform(
            input_dict,
            strip_none=strip_none,
            strip_empty=strip_empty,
        )
        transformed = tm.ok(result, msg=f"{description} failed")
        assert transformed == expected, f"{description}"

    @pytest.mark.parametrize(
        ("description", "input_dict", "key_map", "expected"),
        PowerMethodScenarios.TRANSFORM_KEYS,
    )
    def test_transform_map_keys(
        self,
        description: str,
        input_dict: Mapping[str, t.GeneralValueType],
        key_map: Mapping[str, str],
        expected: Mapping[str, t.GeneralValueType],
    ) -> None:
        """Test transform with map_keys option."""
        # Business Rule: transform accepts dict[str, str] for map_keys, but Mapping is compatible
        # Implication: Convert Mapping to dict for type compatibility
        result = u.transform(input_dict, map_keys=dict(key_map) if key_map else None)
        transformed = tm.ok(result, msg=f"{description} failed")
        assert transformed == expected, f"{description}"

    def test_transform_normalize(self) -> None:
        """Test transform with normalize option."""
        input_data: Mapping[str, t.GeneralValueType] = {
            "Name": "  John  ",
            "Age": 25,
        }
        result = u.transform(input_data, normalize=True)
        transformed = tm.ok(result)
        assert isinstance(transformed, dict)

    def test_transform_to_json(self) -> None:
        """Test transform with to_json option."""
        input_data: Mapping[str, t.GeneralValueType] = {
            "name": "John",
            "active": True,
        }
        result = u.transform(input_data, to_json=True)
        transformed = tm.ok(result)
        # Should be JSON-serializable dict (converts non-JSON values to JSON types)
        assert isinstance(transformed, dict)
        assert transformed == {"name": "John", "active": True}

    def test_transform_strip_empty(self) -> None:
        """Test transform with strip_empty option."""
        input_data: Mapping[str, t.GeneralValueType] = {
            "name": "John",
            "empty": "",
            "items": [],
        }
        result = u.transform(input_data, strip_empty=True)
        transformed = tm.ok(result)
        assert "name" in transformed
        assert "empty" not in transformed

    def test_transform_filter_keys_set(self) -> None:
        """Test transform with filter_keys as set."""
        input_data: Mapping[str, t.GeneralValueType] = {
            "name": "John",
            "age": 25,
            "email": "john@test.com",
        }
        result = u.transform(input_data, filter_keys={"name", "age"})
        transformed = tm.ok(result)
        assert "name" in transformed
        assert "age" in transformed
        assert "email" not in transformed

    def test_transform_exclude_keys(self) -> None:
        """Test transform with exclude_keys option."""
        input_data: Mapping[str, t.GeneralValueType] = {
            "name": "John",
            "password": "secret",
            "age": 25,
        }
        result = u.transform(input_data, exclude_keys={"password"})
        transformed = tm.ok(result)
        assert "name" in transformed
        assert "password" not in transformed

    def test_transform_empty_dict(self) -> None:
        """Test transform with empty dict."""
        result = u.transform({}, normalize=True)
        transformed = tm.ok(result)
        assert transformed == {}

    def test_transform_nested_dict(self) -> None:
        """Test transform with nested dictionary."""
        input_data = {"user": {"name": "John", "age": None}}
        result = u.transform(input_data, strip_none=True)
        transformed = tm.ok(result)
        assert "user" in transformed

    def test_transform_combined_options(self) -> None:
        """Test transform with multiple options combined."""
        input_data = {"old_key": "value", "remove": None}
        result = u.transform(
            input_data,
            strip_none=True,
            map_keys={"old_key": "new_key"},
        )
        transformed = tm.ok(result)
        assert "new_key" in transformed
        assert "remove" not in transformed


# =============================================================================
# TEST CLASS: pipe() POWER METHOD
# =============================================================================


class TestPipeMethod:
    """Tests for u.pipe() power method."""

    # -------------------------------------------------------------------------
    # Basic pipe operations
    # -------------------------------------------------------------------------

    def test_pipe_empty_operations_returns_value(self) -> None:
        """Empty operations returns original value."""
        result = u.pipe("hello")
        value = tm.ok(result)
        assert value == "hello"

    def test_pipe_single_operation(self) -> None:
        """Single operation transforms value."""
        result = u.pipe("hello", str.upper)
        value = tm.ok(result)
        assert value == "HELLO"

    def test_pipe_multiple_operations(self) -> None:
        """Multiple operations chain correctly."""
        result = u.pipe(
            "  hello  ",
            str.strip,
            str.upper,
            lambda s: f"[{s}]",
        )
        value = tm.ok(result)
        assert value == "[HELLO]"

    def test_pipe_with_lambdas(self) -> None:
        """Lambdas work in pipeline."""
        result = u.pipe(
            5,
            lambda x: x * 2,
            lambda x: x + 3,
            lambda x: x * x,
        )
        value = tm.ok(result)
        # (5 * 2) + 3 = 13, 13 * 13 = 169
        assert value == 169

    def test_pipe_type_transformation(self) -> None:
        """Operations can change types through chain."""
        result = u.pipe(
            "42",
            int,
            lambda x: x * 2,
            str,
            lambda s: f"Result: {s}",
        )
        value = tm.ok(result)
        assert value == "Result: 84"

    # -------------------------------------------------------------------------
    # Error handling in pipe
    # -------------------------------------------------------------------------

    def test_pipe_operation_raises_stops(self) -> None:
        """Exception in operation returns Fail (on_error=stop)."""
        result = u.pipe(
            "not-a-number",
            int,  # Will raise ValueError
            lambda x: x * 2,
        )
        error = tm.fail(result)
        assert (
            "int" in error.lower()
            or "invalid" in error.lower()
            or "error" in error.lower()
        )

    def test_pipe_on_error_skip_continues(self) -> None:
        """on_error=skip continues with previous value."""
        # When an operation fails with skip, it uses previous value
        result = u.pipe(
            "test",
            str.upper,
            int,  # Will fail - "TEST" is not a number
            lambda x: f"final: {x}",
            on_error="skip",
        )
        # With skip mode, continues with previous value "TEST"
        value = tm.ok(result)
        assert "TEST" in str(value)

    def test_pipe_first_operation_fails(self) -> None:
        """First operation failing returns Fail."""
        result = u.pipe(
            "abc",
            int,  # Fails immediately
        )
        tm.fail(result)

    def test_pipe_middle_operation_fails(self) -> None:
        """Middle operation failing stops chain."""
        result = u.pipe(
            10,
            lambda x: x + 5,
            lambda x: 1 / (x - 15),  # Division by zero when x=15
            lambda x: x * 100,
        )
        tm.fail(result)

    # -------------------------------------------------------------------------
    # FlextResult handling in pipe
    # -------------------------------------------------------------------------

    def test_pipe_with_flext_result_success_unwrapped(self) -> None:
        """FlextResult.ok values are auto-unwrapped."""
        result = u.pipe(
            "test",
            lambda s: FlextResult[str].ok(s.upper()),
            lambda s: f"[{s}]",
        )
        value = tm.ok(result)
        assert value == "[TEST]"

    def test_pipe_with_flext_result_failure_propagates(self) -> None:
        """FlextResult.fail propagates through pipeline."""
        result = u.pipe(
            "test",
            lambda s: FlextResult[str].fail("validation error"),
            lambda s: s.upper(),  # Should not execute
        )
        error = tm.fail(result)
        assert "validation" in error.lower()

    def test_pipe_mixed_results_and_plain_values(self) -> None:
        """Mix of FlextResult and plain returns works."""
        result = u.pipe(
            5,
            lambda x: x * 2,  # Plain: 10
            lambda x: FlextResult[int].ok(x + 5),  # Result: ok(15)
            lambda x: x * 3,  # Plain: 45
        )
        value = tm.ok(result)
        assert value == 45

    # -------------------------------------------------------------------------
    # Edge cases
    # -------------------------------------------------------------------------

    def test_pipe_none_value(self) -> None:
        """None value can be piped."""
        result = u.pipe(
            None,
            lambda x: x is None,
            lambda b: "yes" if b else "no",
        )
        value = tm.ok(result)
        assert value == "yes"

    def test_pipe_empty_string(self) -> None:
        """Empty string piped correctly."""
        result = u.pipe(
            "",
            len,
            lambda n: n == 0,
        )
        value = tm.ok(result)
        assert value is True

    def test_pipe_dict_transformation(self) -> None:
        """Dict can be transformed through pipe."""
        result = u.pipe(
            {"name": "john"},
            lambda d: {
                **d,
                "upper_name": d["name"].upper(),
            },
            operator.itemgetter("upper_name"),
        )
        value = tm.ok(result)
        assert value == "JOHN"

    def test_pipe_list_operations(self) -> None:
        """List operations in pipe."""
        result = u.pipe(
            [3, 1, 4, 1, 5],
            sorted,
            operator.itemgetter(slice(3)),
            sum,
        )
        value = tm.ok(result)
        assert value == 5  # sorted: [1,1,3,4,5], first 3: [1,1,3], sum: 5


# =============================================================================
# TEST CLASS: merge() POWER METHOD
# =============================================================================


class TestMergeMethod:
    """Tests for u.merge() power method."""

    # -------------------------------------------------------------------------
    # Basic merge operations
    # -------------------------------------------------------------------------

    def test_merge_empty_returns_empty(self) -> None:
        """No dicts returns empty dict."""
        result = u.merge({}, {})
        value = tm.ok(result)
        assert value == {}

    def test_merge_single_dict_returns_copy(self) -> None:
        """Single dict returns copy of it."""
        original: dict[str, t.GeneralValueType] = {"a": 1, "b": 2}
        result = u.merge(original, {})
        value = tm.ok(result)
        assert value == {"a": 1, "b": 2}
        # Verify it's a copy, not same reference
        assert value is not original

    def test_merge_two_dicts_override(self) -> None:
        """Second dict overrides first (shallow)."""
        d1: dict[str, t.GeneralValueType] = {"a": 1, "b": 2}
        d2: dict[str, t.GeneralValueType] = {"b": 3, "c": 4}
        # Convert Mapping to dict for type compatibility
        d1_dict = dict(d1) if isinstance(d1, Mapping) else d1
        d2_dict = dict(d2) if isinstance(d2, Mapping) else d2
        result = u.merge(d1_dict, d2_dict, strategy="override")
        value = tm.ok(result)
        assert value == {"a": 1, "b": 3, "c": 4}

    @pytest.mark.parametrize(
        ("description", "d1", "d2", "strategy", "expected"),
        PowerMethodScenarios.MERGE_STRATEGY,
    )
    def test_merge_strategies(
        self,
        description: str,
        d1: Mapping[str, t.GeneralValueType],
        d2: Mapping[str, t.GeneralValueType],
        strategy: str,
        expected: Mapping[str, t.GeneralValueType],
    ) -> None:
        """Test different merge strategies."""
        # Convert Mapping to dict for type compatibility
        d1_dict = dict(d1) if isinstance(d1, Mapping) else d1
        d2_dict = dict(d2) if isinstance(d2, Mapping) else d2
        result = u.merge(d1_dict, d2_dict, strategy=strategy)
        value = tm.ok(result, msg=f"{description} failed")
        assert value == expected, f"{description}"

    # -------------------------------------------------------------------------
    # Deep merge tests
    # -------------------------------------------------------------------------

    def test_merge_deep_nested_dicts(self) -> None:
        """Deep strategy merges nested dicts."""
        d1: Mapping[str, t.GeneralValueType] = {"a": {"x": 1, "y": 2}, "b": 3}
        d2: Mapping[str, t.GeneralValueType] = {
            "a": {"y": 20, "z": 30},
            "c": 4,
        }
        # Convert Mapping to dict for type compatibility
        d1_dict = dict(d1) if isinstance(d1, Mapping) else d1
        d2_dict = dict(d2) if isinstance(d2, Mapping) else d2
        result = u.merge(d1_dict, d2_dict, strategy="deep")
        value = tm.ok(result)
        assert value == {"a": {"x": 1, "y": 20, "z": 30}, "b": 3, "c": 4}

    def test_merge_deep_three_levels(self) -> None:
        """Deep merge works with deeply nested structures."""
        d1 = {"l1": {"l2": {"l3": {"a": 1}}}}
        d2 = {"l1": {"l2": {"l3": {"b": 2}}}}
        # Convert Mapping to dict for type compatibility
        d1_dict = dict(d1) if isinstance(d1, Mapping) else d1
        d2_dict = dict(d2) if isinstance(d2, Mapping) else d2
        # Type narrowing: d1_dict and d2_dict are dict[str, t.GeneralValueType] compatible
        # u.merge accepts dict[str, t.GeneralValueType] so no cast needed
        result = u.merge(d1_dict, d2_dict, strategy="deep")
        value = tm.ok(result)
        assert value == {"l1": {"l2": {"l3": {"a": 1, "b": 2}}}}

    def test_merge_deep_non_dict_override(self) -> None:
        """Deep merge: non-dict replaces dict."""
        d1: dict[str, t.GeneralValueType] = {"a": {"nested": True}}
        d2: dict[str, t.GeneralValueType] = {"a": "string_value"}
        # Convert Mapping to dict for type compatibility
        d1_dict = dict(d1) if isinstance(d1, Mapping) else d1
        d2_dict = dict(d2) if isinstance(d2, Mapping) else d2
        result = u.merge(d1_dict, d2_dict, strategy="deep")
        value = tm.ok(result)
        assert value == {"a": "string_value"}

    # -------------------------------------------------------------------------
    # Append strategy tests
    # -------------------------------------------------------------------------

    def test_merge_append_lists(self) -> None:
        """Append strategy concatenates lists."""
        d1: dict[str, t.GeneralValueType] = {"items": [1, 2]}
        d2: dict[str, t.GeneralValueType] = {"items": [3, 4]}
        # Convert Mapping to dict for type compatibility
        d1_dict = dict(d1) if isinstance(d1, Mapping) else d1
        d2_dict = dict(d2) if isinstance(d2, Mapping) else d2
        result = u.merge(d1_dict, d2_dict, strategy="append")
        value = tm.ok(result)
        assert value == {"items": [1, 2, 3, 4]}

    def test_merge_append_non_list_overrides(self) -> None:
        """Append strategy: non-lists override."""
        d1: dict[str, t.GeneralValueType] = {"a": 1}
        d2: dict[str, t.GeneralValueType] = {"a": 2}
        # Convert Mapping to dict for type compatibility
        d1_dict = dict(d1) if isinstance(d1, Mapping) else d1
        d2_dict = dict(d2) if isinstance(d2, Mapping) else d2
        result = u.merge(d1_dict, d2_dict, strategy="append")
        value = tm.ok(result)
        assert value == {"a": 2}

    # -------------------------------------------------------------------------
    # Filter options tests
    # -------------------------------------------------------------------------

    def test_merge_filter_none(self) -> None:
        """filter_none skips None values."""
        d1: dict[str, t.GeneralValueType] = {"a": 1}
        d2: dict[str, t.GeneralValueType] = {"a": None, "b": 2}
        # filter_none not supported, using standard merge
        result = u.merge(d1, d2, strategy="filter_none")
        value = tm.ok(result)
        assert value.get("a") == 1  # Not overridden by None
        assert value.get("b") == 2

    def test_merge_filter_empty(self) -> None:
        """filter_empty skips empty values."""
        d1: dict[str, t.GeneralValueType] = {"a": "value"}
        d2: dict[str, t.GeneralValueType] = {"a": "", "b": 2}
        result = u.merge(d1, d2, strategy="filter_empty")
        value = tm.ok(result)
        assert value.get("a") == "value"  # Not overridden by ""
        assert value.get("b") == 2

    def test_merge_filter_both(self) -> None:
        """filter_both skips None and empty values."""
        d1: dict[str, t.GeneralValueType] = {"a": 1, "b": "text"}
        d2: dict[str, t.GeneralValueType] = {"a": None, "b": ""}
        result = u.merge(d1, d2, strategy="filter_both")
        value = tm.ok(result)
        assert value == {"a": 1, "b": "text"}

    # -------------------------------------------------------------------------
    # Multiple dicts merge
    # -------------------------------------------------------------------------

    def test_merge_three_dicts(self) -> None:
        """Three dicts merge correctly."""
        d1: dict[str, t.GeneralValueType] = {"a": 1}
        d2: dict[str, t.GeneralValueType] = {"b": 2}
        d3: dict[str, t.GeneralValueType] = {"c": 3, "a": 10}
        # Merge first two, then merge result with third
        result1 = u.merge(d1, d2)
        result = u.merge(result1.value, d3)
        value = tm.ok(result)
        assert value == {"a": 10, "b": 2, "c": 3}

    def test_merge_many_dicts(self) -> None:
        """Many dicts merge in order."""
        dicts: list[dict[str, t.GeneralValueType]] = [
            {"key": 1},
            {"key": 2},
            {"key": 3},
            {"key": 4},
            {"key": 5},
        ]
        # Merge all dicts sequentially
        result = u.merge(dicts[0], dicts[1])
        for d in dicts[2:]:
            result = u.merge(result.value, d)
        value = tm.ok(result)
        assert value == {"key": 5}  # Last one wins

    # -------------------------------------------------------------------------
    # Edge cases
    # -------------------------------------------------------------------------

    def test_merge_empty_dicts(self) -> None:
        """Empty dicts merge to empty."""
        result = u.merge({}, {})
        result = u.merge(result.value, {})
        value = tm.ok(result)
        assert value == {}

    def test_merge_preserves_types(self) -> None:
        """Merge preserves various value types."""
        d1: dict[str, t.GeneralValueType] = {
            "int": 42,
            "float": math.pi,
            "str": "hello",
            "bool": True,
            "list": [1, 2, 3],
            "dict": {"nested": True},
        }
        result = u.merge(d1, {})
        value = tm.ok(result)
        assert value["int"] == 42
        assert value["float"] == math.pi
        assert value["str"] == "hello"
        assert value["bool"] is True
        assert value["list"] == [1, 2, 3]
        assert value["dict"] == {"nested": True}


# =============================================================================
# TEST CLASS: extract() POWER METHOD
# =============================================================================


class TestExtractMethod:
    """Tests for u.extract() power method."""

    # -------------------------------------------------------------------------
    # Basic extraction
    # -------------------------------------------------------------------------

    def test_extract_simple_key(self) -> None:
        """Extract simple top-level key."""
        data = {"name": "John", "age": 30}
        result = u.extract(data, "name")
        value = tm.ok(result)
        assert value == "John"

    def test_extract_nested_path(self) -> None:
        """Extract nested value with dot notation."""
        data = {"user": {"name": "John", "email": "john@test.com"}}
        result = u.extract(data, "user.name")
        value = tm.ok(result)
        assert value == "John"

    def test_extract_deep_nested(self) -> None:
        """Extract deeply nested value."""
        data = {"level1": {"level2": {"level3": {"value": 42}}}}
        result = u.extract(data, "level1.level2.level3.value")
        value = tm.ok(result)
        assert value == 42

    @pytest.mark.parametrize(
        ("description", "data", "path", "expected"),
        PowerMethodScenarios.EXTRACT_PATH,
    )
    def test_extract_paths(
        self,
        description: str,
        data: Mapping[str, t.GeneralValueType],
        path: str,
        expected: t.GeneralValueType,
    ) -> None:
        """Test path extraction scenarios."""
        result = u.extract(data, path)
        value = tm.ok(result, msg=f"{description} failed")
        assert value == expected, f"{description}"

    # -------------------------------------------------------------------------
    # Array indexing
    # -------------------------------------------------------------------------

    @pytest.mark.parametrize(
        ("description", "data", "path", "expected"),
        PowerMethodScenarios.EXTRACT_ARRAY,
    )
    def test_extract_array_index(
        self,
        description: str,
        data: Mapping[str, t.GeneralValueType],
        path: str,
        expected: t.GeneralValueType,
    ) -> None:
        """Test array index extraction."""
        result = u.extract(data, path)
        value = tm.ok(result, msg=f"{description} failed")
        assert value == expected, f"{description}"

    def test_extract_array_first_element(self) -> None:
        """Extract first element from array."""
        data = {"items": [10, 20, 30]}
        result = u.extract(data, "items[0]")
        value = tm.ok(result)
        assert value == 10

    def test_extract_array_last_element(self) -> None:
        """Extract last element from array."""
        data = {"items": [10, 20, 30]}
        result = u.extract(data, "items[-1]")
        value = tm.ok(result)
        assert value == 30

    def test_extract_nested_array(self) -> None:
        """Extract from nested array (consecutive indexes need proper path)."""
        data = {"matrix": {"row0": [1, 2], "row1": [3, 4]}}
        # Extract first element from row0
        result = u.extract(data, "matrix.row0[0]")
        value = tm.ok(result)
        assert value == 1

    # -------------------------------------------------------------------------
    # Default values
    # -------------------------------------------------------------------------

    def test_extract_missing_key_returns_default(self) -> None:
        """Missing key returns default value."""
        data = {"a": 1}
        result = u.extract(data, "missing", default="fallback")
        value = tm.ok(result)
        assert value == "fallback"

    def test_extract_missing_nested_returns_sentinel(self) -> None:
        """Missing nested key returns sentinel (non-None default)."""
        data = {"user": {"name": "John"}}
        # FlextResult cannot have None as success value, so use sentinel
        result = u.extract(data, "user.missing.deep", default="NOT_FOUND")
        value = tm.ok(result)
        assert value == "NOT_FOUND"

    def test_extract_missing_with_none_default_fails(self) -> None:
        """Missing key with None default returns failure (FlextResult constraint)."""
        data = {"a": 1}
        # FlextResult cannot have None as success value
        result = u.extract(data, "missing")
        # This should fail because default=None can't be wrapped in FlextResult.ok()
        tm.fail(result)

    # -------------------------------------------------------------------------
    # Required option
    # -------------------------------------------------------------------------

    def test_extract_required_success(self) -> None:
        """Required extraction succeeds when path exists."""
        data = {"key": "value"}
        result = u.extract(data, "key", required=True)
        value = tm.ok(result)
        assert value == "value"

    def test_extract_required_fails_when_missing(self) -> None:
        """Required extraction fails when path missing."""
        data = {"a": 1}
        result = u.extract(data, "missing", required=True)
        error = tm.fail(result)
        assert (
            "missing" in error.lower()
            or "not found" in error.lower()
            or "path" in error.lower()
        )

    def test_extract_required_nested_fails(self) -> None:
        """Required extraction fails for missing nested path."""
        data = {"user": {"name": "John"}}
        result = u.extract(data, "user.email", required=True)
        tm.fail(result)

    # -------------------------------------------------------------------------
    # Custom separator
    # -------------------------------------------------------------------------

    def test_extract_custom_separator_slash(self) -> None:
        """Custom separator: forward slash."""
        data = {"user": {"profile": {"name": "John"}}}
        result = u.extract(data, "user/profile/name", separator="/")
        value = tm.ok(result)
        assert value == "John"

    def test_extract_custom_separator_arrow(self) -> None:
        """Custom separator: arrow."""
        data = {"a": {"b": {"c": 100}}}
        result = u.extract(data, "a->b->c", separator="->")
        value = tm.ok(result)
        assert value == 100

    # -------------------------------------------------------------------------
    # Edge cases
    # -------------------------------------------------------------------------

    def test_extract_from_empty_dict(self) -> None:
        """Extract from empty dict returns default."""
        data: dict[str, t.GeneralValueType] = {}
        result = u.extract(data, "any.path", default="default")
        value = tm.ok(result)
        assert value == "default"

    def test_extract_none_in_path_fails(self) -> None:
        """Extract fails when path traverses None value and no default provided."""
        data: dict[str, t.GeneralValueType] = {"a": None}
        # Cannot traverse None to get "b", and default is None -> fails
        result = u.extract(data, "a.b", default=None)
        tm.fail(result)

        # With non-None default, should return default (success)
        result_with_default = u.extract(data, "a.b", default="fallback")
        value = tm.ok(result_with_default)
        assert value == "fallback"

        # With required=True, should fail even with default
        result_required = u.extract(data, "a.b", required=True)
        tm.fail(result_required)

    def test_extract_preserves_types(self) -> None:
        """Extract preserves various value types."""
        data = {
            "int_val": 42,
            "str_val": "hello",
            "bool_val": True,
            "list_val": [1, 2, 3],
        }
        int_val = tm.ok(
            u.extract(data, "int_val"),
        )
        assert int_val == 42
        str_val = tm.ok(
            u.extract(data, "str_val"),
        )
        assert str_val == "hello"
        bool_val = tm.ok(
            u.extract(data, "bool_val"),
        )
        assert bool(bool_val)  # Check truthy value without type narrowing
        list_val = tm.ok(
            u.extract(data, "list_val"),
        )
        assert list_val == [1, 2, 3]


# =============================================================================
# TEST CLASS: generate() POWER METHOD
# =============================================================================


class TestGenerateMethod:
    """Tests for u.generate() power method."""

    # -------------------------------------------------------------------------
    # Basic generation by kind
    # -------------------------------------------------------------------------

    @pytest.mark.parametrize(
        ("description", "kind", "expected_prefix"),
        PowerMethodScenarios.GENERATE_KINDS,
    )
    def test_generate_kinds(
        self,
        description: str,
        kind: str,
        expected_prefix: str,
    ) -> None:
        """Test different ID generation kinds."""
        result = u.generate(kind)
        assert isinstance(result, str)
        if expected_prefix:
            assert result.startswith(f"{expected_prefix}_"), (
                f"{description}: expected prefix '{expected_prefix}_'"
            )

    def test_generate_default_id(self) -> None:
        """Default generation produces UUID."""
        result = u.generate()
        assert isinstance(result, str)
        # Default is UUID format (36 chars: 8-4-4-4-12)
        assert len(result) == 36

    def test_generate_uuid(self) -> None:
        """UUID generation produces valid UUID format."""
        result = u.generate("uuid")
        assert isinstance(result, str)
        # UUID4 format: 8-4-4-4-12 hex chars
        assert len(result) == 36
        assert result.count("-") == 4

    def test_generate_correlation_id(self) -> None:
        """Correlation ID has 'corr' prefix."""
        result = u.generate("correlation")
        assert result.startswith("corr_")

    def test_generate_entity_id(self) -> None:
        """Entity ID has 'ent' prefix."""
        result = u.generate("entity")
        assert result.startswith("ent_")

    def test_generate_batch_id(self) -> None:
        """Batch ID has 'batch' prefix."""
        result = u.generate("batch")
        assert result.startswith("batch_")

    def test_generate_transaction_id(self) -> None:
        """Transaction ID has 'txn' prefix."""
        result = u.generate("transaction")
        assert result.startswith("txn_")

    def test_generate_event_id(self) -> None:
        """Event ID has 'evt' prefix."""
        result = u.generate("event")
        assert result.startswith("evt_")

    def test_generate_command_id(self) -> None:
        """Command ID has 'cmd' prefix."""
        result = u.generate("command")
        assert result.startswith("cmd_")

    def test_generate_query_id(self) -> None:
        """Query ID has 'qry' prefix."""
        result = u.generate("query")
        assert result.startswith("qry_")

    # -------------------------------------------------------------------------
    # Custom prefix
    # -------------------------------------------------------------------------

    def test_generate_custom_prefix(self) -> None:
        """Custom prefix overrides default."""
        result = u.generate("entity", prefix="user")
        assert result.startswith("user_")

    def test_generate_custom_prefix_empty(self) -> None:
        """Empty custom prefix produces no prefix."""
        result = u.generate("entity", prefix="")
        # With empty prefix, should just be the ID
        assert "_" not in result or not result.startswith("ent_")

    # -------------------------------------------------------------------------
    # Custom length
    # -------------------------------------------------------------------------

    def test_generate_ulid_short_format(self) -> None:
        """ULID generation produces short ID (8 chars)."""
        result = u.generate("ulid")
        assert isinstance(result, str)
        assert len(result) == 8

    def test_generate_custom_prefix_for_id(self) -> None:
        """Custom prefix is applied to id generation."""
        result = u.generate("id", prefix="custom")
        assert result.startswith("custom_")

    def test_generate_with_prefix_and_length(self) -> None:
        """Prefix + custom length."""
        result = u.generate("entity", length=6)
        parts = result.split("_")
        assert parts[0] == "ent"
        assert len(parts[1]) == 6

    # -------------------------------------------------------------------------
    # Timestamp option
    # -------------------------------------------------------------------------

    def test_generate_with_timestamp(self) -> None:
        """Include timestamp in ID."""
        result = u.generate("batch", include_timestamp=True)
        parts = result.split("_")
        assert parts[0] == "batch"
        # Should have timestamp component
        assert len(parts) >= 2

    # -------------------------------------------------------------------------
    # Custom separator
    # -------------------------------------------------------------------------

    def test_generate_custom_separator_dash(self) -> None:
        """Use dash separator."""
        result = u.generate("entity", separator="-")
        assert "-" in result
        assert result.startswith("ent-")

    def test_generate_custom_separator_dot(self) -> None:
        """Use dot separator."""
        result = u.generate("entity", separator=".")
        assert "." in result
        assert result.startswith("ent.")

    # -------------------------------------------------------------------------
    # Uniqueness tests
    # -------------------------------------------------------------------------

    def test_generate_uniqueness(self) -> None:
        """Generated IDs are unique."""
        ids = [u.generate() for _ in range(100)]
        assert len(ids) == len(set(ids))  # All unique

    def test_generate_uuid_uniqueness(self) -> None:
        """Generated UUIDs are unique."""
        uuids = [u.generate("uuid") for _ in range(100)]
        assert len(uuids) == len(set(uuids))

    def test_generate_entity_uniqueness(self) -> None:
        """Generated entity IDs are unique."""
        entity_ids = [u.generate("entity") for _ in range(100)]
        assert len(entity_ids) == len(set(entity_ids))


class TestBatchMethod:
    """Tests for u.batch() power method."""

    # =========================================================================
    # Basic batch processing
    # =========================================================================

    def test_batch_empty_items_returns_empty_results(self) -> None:
        """Batch processing empty items returns empty results."""
        result = u.batch([], lambda x: x * 2)
        tm.ok(result)
        batch_result = result.value
        assert batch_result["results"] == []
        assert batch_result["total"] == 0

    def test_batch_single_item(self) -> None:
        """Batch processing single item works correctly."""
        result = u.batch([5], lambda x: x * 2)
        tm.ok(result)
        batch_result = result.value
        assert batch_result["results"] == [10]
        assert batch_result["total"] == 1
        assert batch_result["success_count"] == 1
        assert batch_result["error_count"] == 0

    def test_batch_multiple_items(self) -> None:
        """Batch processing multiple items transforms all."""
        result = u.batch([1, 2, 3, 4, 5], lambda x: x * 2)
        tm.ok(result)
        batch_result = result.value
        assert batch_result["results"] == [2, 4, 6, 8, 10]
        assert batch_result["total"] == 5
        assert batch_result["success_count"] == 5

    def test_batch_string_items(self) -> None:
        """Batch processes string items."""
        result = u.batch(["hello", "world"], lambda s: s.upper())
        tm.ok(result)
        batch_result = result.value
        assert batch_result["results"] == ["HELLO", "WORLD"]

    def test_batch_dict_items(self) -> None:
        """Batch processes dict items."""
        items = [{"a": 1}, {"a": 2}, {"a": 3}]
        result = u.batch(items, lambda d: d["a"] * 2)
        tm.ok(result)
        batch_result = result.value
        assert batch_result["results"] == [2, 4, 6]

    # =========================================================================
    # Error handling modes
    # =========================================================================

    def test_batch_on_error_collect_continues(self) -> None:
        """On error collect mode continues and collects errors."""

        def operation(x: int) -> int:
            if x == 3:
                msg = "Error on 3"
                raise ValueError(msg)
            return x * 2

        result = u.batch([1, 2, 3, 4, 5], operation, on_error="collect")
        tm.ok(result)
        batch_result = result.value
        assert batch_result["results"] == [2, 4, 8, 10]  # 3 is skipped
        assert batch_result["error_count"] == 1
        assert len(batch_result["errors"]) == 1

    def test_batch_on_error_skip_silently(self) -> None:
        """On error skip mode continues processing silently."""

        def operation(x: int) -> int:
            if x % 2 == 0:
                msg = "Even numbers fail"
                raise ValueError(msg)
            return x

        result = u.batch([1, 2, 3, 4, 5], operation, on_error="skip")
        tm.ok(result)
        batch_result = result.value
        assert batch_result["results"] == [1, 3, 5]
        # Skip mode doesn't collect errors
        assert batch_result["error_count"] == 0

    def test_batch_on_error_fail_stops(self) -> None:
        """On error fail mode returns FlextResult.fail on first error."""

        def operation(x: int) -> int:
            if x == 3:
                msg = "Error on 3"
                raise ValueError(msg)
            return x * 2

        result = u.batch([1, 2, 3, 4, 5], operation, on_error="fail")
        # on_error="fail" returns FlextResult.fail when error occurs
        tm.fail(result)
        assert result.error is not None
        assert "Error on 3" in result.error

    def test_batch_all_items_fail(self) -> None:
        """Batch where all items fail."""

        def always_fail(x: int) -> int:
            msg = f"Fail on {x}"
            raise ValueError(msg)

        result = u.batch([1, 2, 3], always_fail, on_error="collect")
        tm.ok(result)
        batch_result = result.value
        assert batch_result["results"] == []
        assert batch_result["error_count"] == 3
        assert batch_result["success_count"] == 0

    # =========================================================================
    # Edge cases
    # =========================================================================

    def test_batch_with_none_in_items(self) -> None:
        """Batch handles None values in items."""
        result = u.batch([1, None, 3], lambda x: x or 0)
        tm.ok(result)
        batch_result = result.value
        assert batch_result["results"] == [1, 0, 3]

    def test_batch_large_list(self) -> None:
        """Batch handles large item count."""
        items = list(range(100))
        result = u.batch(items, lambda x: x + 1)
        tm.ok(result)
        batch_result = result.value
        assert batch_result["total"] == 100
        assert batch_result["success_count"] == 100
        assert batch_result["results"] == list(range(1, 101))

    def test_batch_identity_operation(self) -> None:
        """Batch with identity operation returns same items."""
        items = [1, 2, 3]
        result = u.batch(items, lambda x: x)
        tm.ok(result)
        batch_result = result.value
        assert batch_result["results"] == items

    def test_batch_complex_transformation(self) -> None:
        """Batch with complex transformation."""
        items = [{"name": "alice"}, {"name": "bob"}]
        result = u.batch(
            items,
            lambda d: {"name": d["name"].upper(), "processed": True},
        )
        tm.ok(result)
        batch_result = result.value
        assert batch_result["results"] == [
            {"name": "ALICE", "processed": True},
            {"name": "BOB", "processed": True},
        ]

    def test_batch_mixed_success_failure(self) -> None:
        """Batch with alternating success and failure."""

        def alternate(x: int) -> int:
            if x % 2 == 0:
                msg = f"Even {x}"
                raise ValueError(msg)
            return x * 10

        result = u.batch([1, 2, 3, 4, 5], alternate, on_error="collect")
        tm.ok(result)
        batch_result = result.value
        assert batch_result["results"] == [10, 30, 50]
        assert batch_result["success_count"] == 3
        assert batch_result["error_count"] == 2


class TestRetryMethod:
    """Tests for u.retry() power method."""

    # =========================================================================
    # Basic retry behavior
    # =========================================================================

    def test_retry_succeeds_first_attempt(self) -> None:
        """Retry succeeds on first attempt."""
        result = u.retry(lambda: 42, max_attempts=3)
        tm.ok(result)
        assert result.value == 42

    def test_retry_succeeds_after_failures(self) -> None:
        """Retry succeeds after initial failures."""
        attempts = [0]

        def flaky() -> int:
            attempts[0] += 1
            if attempts[0] < 3:
                msg = f"Attempt {attempts[0]} failed"
                raise ValueError(msg)
            return 100

        result = u.retry(flaky, max_attempts=5, delay=0.01)
        tm.ok(result)
        assert result.value == 100
        assert attempts[0] == 3

    def test_retry_exhausts_max_attempts(self) -> None:
        """Retry fails after exhausting max attempts."""

        def always_fail() -> int:
            msg = "Always fails"
            raise ValueError(msg)

        result = u.retry(always_fail, max_attempts=3, delay=0.01)
        tm.fail(result)
        assert result.error is not None
        assert "Always fails" in result.error

    def test_retry_max_attempts_one(self) -> None:
        """Retry with max_attempts=1 runs once."""
        attempts = [0]

        def fail_once() -> int:
            attempts[0] += 1
            msg = "Fail"
            raise ValueError(msg)

        result = u.retry(fail_once, max_attempts=1, delay=0.01)
        tm.fail(result)
        assert attempts[0] == 1

    # =========================================================================
    # Exception filtering
    # =========================================================================

    def test_retry_on_specific_exception(self) -> None:
        """Retry only on specific exception types."""
        attempts = [0]

        def fail_value_error() -> int:
            attempts[0] += 1
            if attempts[0] < 2:
                msg = "Retry this"
                raise ValueError(msg)
            return 42

        result = u.retry(
            fail_value_error,
            max_attempts=3,
            delay=0.01,
            retry_on=(ValueError,),
        )
        tm.ok(result)
        assert attempts[0] == 2

    def test_retry_does_not_retry_excluded_exception(self) -> None:
        """Retry propagates exception when not in retry_on tuple."""

        def fail_type_error() -> int:
            msg = "Type error - don't retry"
            raise TypeError(msg)

        # Current implementation lets non-retryable exceptions propagate
        with pytest.raises(TypeError, match="Type error"):
            u.retry(
                fail_type_error,
                max_attempts=3,
                delay=0.01,
                retry_on=(ValueError,),  # Only retry ValueError
            )

    # =========================================================================
    # Delay and backoff
    # =========================================================================

    def test_retry_with_zero_delay(self) -> None:
        """Retry with zero delay works."""
        attempts = [0]

        def fail_twice() -> int:
            attempts[0] += 1
            if attempts[0] < 3:
                msg = "Fail"
                raise ValueError(msg)
            return 99

        result = u.retry(fail_twice, max_attempts=5, delay=0)
        tm.ok(result)
        assert result.value == 99

    def test_retry_with_small_delay(self) -> None:
        """Retry with small delay works."""
        attempts = [0]

        def fail_once() -> str:
            attempts[0] += 1
            if attempts[0] < 2:
                msg = "First fail"
                raise ValueError(msg)
            return "success"

        result = u.retry(fail_once, max_attempts=3, delay=0.001)
        tm.ok(result)
        assert result.value == "success"

    # =========================================================================
    # Return value types
    # =========================================================================

    def test_retry_returns_string(self) -> None:
        """Retry can return string value."""
        result = u.retry(lambda: "hello", max_attempts=1)
        tm.ok(result)
        assert result.value == "hello"

    def test_retry_returns_dict(self) -> None:
        """Retry can return dict value."""
        result = u.retry(lambda: {"key": "value"}, max_attempts=1)
        tm.ok(result)
        assert result.value == {"key": "value"}

    def test_retry_returns_list(self) -> None:
        """Retry can return list value."""
        result = u.retry(lambda: [1, 2, 3], max_attempts=1)
        tm.ok(result)
        assert result.value == [1, 2, 3]

    # =========================================================================
    # Edge cases
    # =========================================================================

    def test_retry_function_with_side_effects(self) -> None:
        """Retry tracks side effects across attempts."""
        state = {"count": 0}

        def increment_and_fail() -> int:
            state["count"] += 1
            if state["count"] < 4:
                msg = f"Count is {state['count']}"
                raise ValueError(msg)
            return state["count"]

        result = u.retry(
            increment_and_fail,
            max_attempts=5,
            delay=0.01,
        )
        tm.ok(result)
        assert result.value == 4
        assert state["count"] == 4

    def test_retry_immediate_success_no_delay(self) -> None:
        """Immediate success doesn't incur delay."""
        start = time.time()
        result = u.retry(lambda: "fast", max_attempts=3, delay=1.0)
        elapsed = time.time() - start

        tm.ok(result)
        assert elapsed < 0.5  # Should be nearly instant

    def test_retry_preserves_exception_message(self) -> None:
        """Retry preserves the original exception message."""

        def specific_error() -> int:
            msg = "Specific error XYZ123"
            raise ValueError(msg)

        result = u.retry(specific_error, max_attempts=2, delay=0.01)
        tm.fail(result)
        assert result.error is not None
        assert "XYZ123" in result.error
