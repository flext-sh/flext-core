"""Tests for flext_core.config.validators module."""

import os
from pathlib import Path

import pytest

from flext_core.config.validators import validate_database_url
from flext_core.config.validators import validate_environment
from flext_core.config.validators import validate_log_level
from flext_core.config.validators import validate_port
from flext_core.config.validators import validate_project_name
from flext_core.config.validators import validate_timeout
from flext_core.config.validators import validate_url
from flext_core.config.validators import validate_version
from flext_core.domain.constants import Environments


class TestConfigurationValidator:
    """Test ConfigurationValidator functionality."""

    def test_validate_basic_config(self) -> None:
        """Test validation of basic configuration."""
        config_dict = {
            "project_name": "test-project",
            "environment": "development",
            "debug": True,
        }

        validator = ConfigurationValidator()
        result = validator.validate(config_dict)

        assert result.is_success
        assert result.value is not None
        assert result.value["project_name"] == "test-project"

    def test_validate_invalid_config(self) -> None:
        """Test validation with invalid configuration."""
        config_dict = {
            "project_name": "",  # Invalid empty name
            "environment": "invalid-env",  # Invalid environment
        }

        validator = ConfigurationValidator()
        result = validator.validate(config_dict)

        assert not result.is_success
        assert result.error is not None
        assert "project_name" in result.error or "environment" in result.error

    def test_validate_missing_required_fields(self) -> None:
        """Test validation with missing required fields."""
        config_dict = {
            "debug": True,  # Missing project_name and environment
        }

        validator = ConfigurationValidator()
        result = validator.validate(config_dict)

        assert not result.is_success
        assert result.error is not None


class TestProjectNameValidator:
    """Test ProjectNameValidator functionality."""

    def test_validate_valid_project_names(self) -> None:
        """Test validation of valid project names."""
        valid_names = [
            "test-project",
            "test_project",
            "testproject",
            "test123",
            "my-awesome-project",
        ]

        validator = ProjectNameValidator()

        for name in valid_names:
            result = validator.validate(name)
            assert result.is_success, f"Failed for valid name: {name}"
            assert result.value == name

    def test_validate_invalid_project_names(self) -> None:
        """Test validation of invalid project names."""
        invalid_names = [
            "",  # Empty
            "a",  # Too short
            "123project",  # Starts with number
            "project with spaces",  # Contains spaces
            "project@name",  # Invalid characters
            "x" * 100,  # Too long
        ]

        validator = ProjectNameValidator()

        for name in invalid_names:
            result = validator.validate(name)
            assert not result.is_success, f"Should fail for invalid name: {name}"
            assert result.error is not None

    def test_validate_none_input(self) -> None:
        """Test validation with None input."""
        validator = ProjectNameValidator()
        result = validator.validate(None)

        assert not result.is_success
        assert "must be a string" in result.error


class TestVersionValidator:
    """Test VersionValidator functionality."""

    def test_validate_valid_versions(self) -> None:
        """Test validation of valid semantic versions."""
        valid_versions = [
            "1.0.0",
            "0.1.0",
            "10.20.30",
            "1.0.0-alpha",
            "1.0.0-beta.1",
            "1.0.0-rc.1",
        ]

        validator = VersionValidator()

        for version in valid_versions:
            result = validator.validate(version)
            assert result.is_success, f"Failed for valid version: {version}"
            assert result.value == version

    def test_validate_invalid_versions(self) -> None:
        """Test validation of invalid versions."""
        invalid_versions = [
            "",  # Empty
            "1.0",  # Missing patch
            "1",  # Only major
            "v1.0.0",  # With v prefix
            "1.0.0.0",  # Too many parts
            "1.0.a",  # Non-numeric patch
            "1.0.0-",  # Invalid pre-release
        ]

        validator = VersionValidator()

        for version in invalid_versions:
            result = validator.validate(version)
            assert not result.is_success, f"Should fail for invalid version: {version}"
            assert result.error is not None


class TestEnvironmentValidator:
    """Test EnvironmentValidator functionality."""

    def test_validate_valid_environments(self) -> None:
        """Test validation of valid environments."""
        valid_envs = [
            Environments.DEVELOPMENT,
            Environments.STAGING,
            Environments.PRODUCTION,
            Environments.TEST,
        ]

        validator = EnvironmentValidator()

        for env in valid_envs:
            result = validator.validate(env)
            assert result.is_success, f"Failed for valid environment: {env}"
            assert result.value == env

    def test_validate_invalid_environments(self) -> None:
        """Test validation of invalid environments."""
        invalid_envs = [
            "",  # Empty
            "invalid",  # Not in allowed list
            "DEVELOPMENT",  # Wrong case
            "dev",  # Abbreviated
            None,  # None value
        ]

        validator = EnvironmentValidator()

        for env in invalid_envs:
            result = validator.validate(env)
            assert not result.is_success, f"Should fail for invalid environment: {env}"
            assert result.error is not None

    def test_environment_case_sensitivity(self) -> None:
        """Test environment validation is case sensitive."""
        validator = EnvironmentValidator()

        # Lowercase should work
        result = validator.validate("development")
        assert result.is_success

        # Uppercase should fail
        result = validator.validate("DEVELOPMENT")
        assert not result.is_success


class TestConfigFileValidator:
    """Test ConfigFileValidator functionality."""

    def test_validate_existing_file(self, tmp_path: Path) -> None:
        """Test validation of existing config file."""
        # Create a temporary config file
        config_file = tmp_path / "test.env"
        config_file.write_text("PROJECT_NAME=test\nENVIRONMENT=development\n")

        validator = ConfigFileValidator()
        result = validator.validate(str(config_file))

        assert result.is_success
        assert result.value == str(config_file)

    def test_validate_non_existing_file(self) -> None:
        """Test validation of non-existing file."""
        validator = ConfigFileValidator()
        result = validator.validate("/path/to/non/existing/file.env")

        assert not result.is_success
        assert "does not exist" in result.error

    def test_validate_directory_instead_of_file(self, tmp_path: Path) -> None:
        """Test validation when path is a directory."""
        validator = ConfigFileValidator()
        result = validator.validate(str(tmp_path))

        assert not result.is_success
        assert "not a file" in result.error

    def test_validate_invalid_extension(self, tmp_path: Path) -> None:
        """Test validation of file with wrong extension."""
        # Create a file with wrong extension
        config_file = tmp_path / "test.txt"
        config_file.write_text("content")

        validator = ConfigFileValidator()
        result = validator.validate(str(config_file))

        # Should still pass if file exists - extension validation might be separate
        # Adjust this based on actual implementation
        assert result.is_success or "extension" in result.error


class TestSecretsValidator:
    """Test SecretsValidator functionality."""

    def test_validate_safe_config(self) -> None:
        """Test validation of configuration without secrets."""
        safe_config = {
            "project_name": "test-project",
            "environment": "development",
            "debug": True,
            "timeout": 30,
        }

        validator = SecretsValidator()
        result = validator.validate(safe_config)

        assert result.is_success
        assert result.value == safe_config

    def test_detect_password_in_config(self) -> None:
        """Test detection of password in configuration."""
        config_with_password = {
            "project_name": "test-project",
            "database_password": "secret123",  # Should be detected
            "environment": "development",
        }

        validator = SecretsValidator()
        result = validator.validate(config_with_password)

        assert not result.is_success
        assert "password" in result.error.lower()

    def test_detect_key_in_config(self) -> None:
        """Test detection of key/token in configuration."""
        config_with_key = {
            "project_name": "test-project",
            "api_key": "abc123def456",  # Should be detected
            "access_token": "token123",  # Should be detected
        }

        validator = SecretsValidator()
        result = validator.validate(config_with_key)

        assert not result.is_success
        assert ("key" in result.error.lower() or "token" in result.error.lower())

    def test_allow_placeholder_secrets(self) -> None:
        """Test that placeholder values are allowed."""
        config_with_placeholders = {
            "project_name": "test-project",
            "database_password": "${DATABASE_PASSWORD}",  # Placeholder
            "api_key": "{{API_KEY}}",  # Template placeholder
        }

        validator = SecretsValidator()
        result = validator.validate(config_with_placeholders)

        # Should pass as these are placeholders, not actual secrets
        assert result.is_success or "placeholder" in result.error


class TestValidatorIntegration:
    """Test validator integration and combined usage."""

    def test_multiple_validators_chain(self) -> None:
        """Test chaining multiple validators."""
        # This would test the actual implementation pattern
        project_validator = ProjectNameValidator()
        env_validator = EnvironmentValidator()

        # Valid case
        project_result = project_validator.validate("test-project")
        env_result = env_validator.validate("development")

        assert project_result.is_success
        assert env_result.is_success

        # Invalid case
        invalid_project = project_validator.validate("")
        invalid_env = env_validator.validate("invalid")

        assert not invalid_project.is_success
        assert not invalid_env.is_success

    def test_configuration_validator_uses_subvalidators(self) -> None:
        """Test that ConfigurationValidator uses other validators."""
        config_dict = {
            "project_name": "valid-project",
            "environment": "development",
            "version": "1.0.0",
        }

        validator = ConfigurationValidator()
        result = validator.validate(config_dict)

        # Should validate all fields using appropriate validators
        assert result.is_success


class TestValidatorErrorHandling:
    """Test error handling in validators."""

    def test_validator_handles_none_input(self) -> None:
        """Test all validators handle None input gracefully."""
        validators = [
            ProjectNameValidator(),
            VersionValidator(),
            EnvironmentValidator(),
        ]

        for validator in validators:
            result = validator.validate(None)
            assert not result.is_success
            assert result.error is not None
            assert "None" in result.error or "required" in result.error

    def test_validator_handles_wrong_type_input(self) -> None:
        """Test validators handle wrong input types."""
        validators = [
            ProjectNameValidator(),
            VersionValidator(),
            EnvironmentValidator(),
        ]

        wrong_inputs = [123, [], {}, True]

        for validator in validators:
            for wrong_input in wrong_inputs:
                result = validator.validate(wrong_input)
                assert not result.is_success
                assert result.error is not None

    def test_configuration_validator_handles_malformed_dict(self) -> None:
        """Test ConfigurationValidator handles malformed dictionaries."""
        malformed_configs = [
            None,
            "not a dict",
            [],
            123,
        ]

        validator = ConfigurationValidator()

        for config in malformed_configs:
            result = validator.validate(config)
            assert not result.is_success
            assert result.error is not None
