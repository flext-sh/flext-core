"""Tests for flext_core.config.adapters module."""

import os
from pathlib import Path
from unittest.mock import Mock
from unittest.mock import patch

import pytest

from flext_core.config.adapters import ConfigAdapter
from flext_core.config.adapters import DatabaseConfigAdapter
from flext_core.config.adapters import EnvironmentConfigAdapter
from flext_core.config.adapters import FileConfigAdapter


class TestConfigAdapter:
    """Test base ConfigAdapter functionality."""

    def test_config_adapter_interface(self) -> None:
        """Test ConfigAdapter base interface."""
        # ConfigAdapter should be abstract/protocol
        adapter = ConfigAdapter()
        assert adapter is not None
        assert hasattr(adapter, "load")
        assert hasattr(adapter, "save")

    def test_config_adapter_load_method(self) -> None:
        """Test ConfigAdapter load method exists."""
        adapter = ConfigAdapter()

        # Should have load method (might be abstract)
        assert callable(getattr(adapter, "load", None))

    def test_config_adapter_save_method(self) -> None:
        """Test ConfigAdapter save method exists."""
        adapter = ConfigAdapter()

        # Should have save method (might be abstract)
        assert callable(getattr(adapter, "save", None))


class TestFileConfigAdapter:
    """Test FileConfigAdapter functionality."""

    def test_load_existing_env_file(self, tmp_path: Path) -> None:
        """Test loading existing .env file."""
        # Create a test .env file
        env_file = tmp_path / ".env"
        env_content = """
PROJECT_NAME=test-project
ENVIRONMENT=development
DEBUG=true
TIMEOUT=30
"""
        env_file.write_text(env_content.strip())

        adapter = FileConfigAdapter(str(env_file))
        result = adapter.load()

        assert result.is_success
        config = result.value
        assert config["PROJECT_NAME"] == "test-project"
        assert config["ENVIRONMENT"] == "development"
        assert config["DEBUG"] == "true"
        assert config["TIMEOUT"] == "30"

    def test_load_non_existing_file(self) -> None:
        """Test loading non-existing file."""
        adapter = FileConfigAdapter("/path/to/non/existing/file.env")
        result = adapter.load()

        assert not result.is_success
        assert "not found" in result.error or "does not exist" in result.error

    def test_load_malformed_env_file(self, tmp_path: Path) -> None:
        """Test loading malformed .env file."""
        # Create a malformed .env file
        env_file = tmp_path / ".env"
        env_content = """
PROJECT_NAME=test-project
INVALID LINE WITHOUT EQUALS
ENVIRONMENT=development
"""
        env_file.write_text(env_content.strip())

        adapter = FileConfigAdapter(str(env_file))
        result = adapter.load()

        # Should either skip invalid lines or return error
        # Adjust assertion based on actual implementation
        assert result.is_success or "malformed" in result.error

    def test_save_config_to_file(self, tmp_path: Path) -> None:
        """Test saving configuration to file."""
        env_file = tmp_path / ".env"
        config_data = {
            "PROJECT_NAME": "test-project",
            "ENVIRONMENT": "development",
            "DEBUG": "true",
        }

        adapter = FileConfigAdapter(str(env_file))
        result = adapter.save(config_data)

        assert result.is_success

        # Verify file was created and contains expected content
        assert env_file.exists()
        content = env_file.read_text()
        assert "PROJECT_NAME=test-project" in content
        assert "ENVIRONMENT=development" in content

    def test_save_to_readonly_location(self) -> None:
        """Test saving to read-only location."""
        # Try to save to a location we can't write to
        adapter = FileConfigAdapter("/readonly/path/.env")
        config_data = {"TEST": "value"}

        result = adapter.save(config_data)

        assert not result.is_success
        assert "permission" in result.error.lower() or "access" in result.error.lower()

    def test_load_empty_file(self, tmp_path: Path) -> None:
        """Test loading empty .env file."""
        env_file = tmp_path / ".env"
        env_file.write_text("")

        adapter = FileConfigAdapter(str(env_file))
        result = adapter.load()

        assert result.is_success
        assert result.value == {}  # Should return empty dict

    def test_load_file_with_comments(self, tmp_path: Path) -> None:
        """Test loading .env file with comments."""
        env_file = tmp_path / ".env"
        env_content = """
# This is a comment
PROJECT_NAME=test-project
# Another comment
ENVIRONMENT=development  # Inline comment
"""
        env_file.write_text(env_content.strip())

        adapter = FileConfigAdapter(str(env_file))
        result = adapter.load()

        assert result.is_success
        config = result.value
        assert config["PROJECT_NAME"] == "test-project"
        assert config["ENVIRONMENT"] == "development"
        # Comments should be ignored


class TestEnvironmentConfigAdapter:
    """Test EnvironmentConfigAdapter functionality."""

    def test_load_environment_variables(self) -> None:
        """Test loading environment variables."""
        # Set some test environment variables
        test_env = {
            "FLEXT_PROJECT_NAME": "test-project",
            "FLEXT_ENVIRONMENT": "development",
            "FLEXT_DEBUG": "true",
            "OTHER_VAR": "should-be-ignored",  # No FLEXT_ prefix
        }

        with patch.dict(os.environ, test_env, clear=False):
            adapter = EnvironmentConfigAdapter(prefix="FLEXT_")
            result = adapter.load()

            assert result.is_success
            config = result.value
            assert "PROJECT_NAME" in config or "FLEXT_PROJECT_NAME" in config
            assert "OTHER_VAR" not in config  # Should be filtered out

    def test_load_without_prefix(self) -> None:
        """Test loading environment variables without prefix filter."""
        adapter = EnvironmentConfigAdapter()
        result = adapter.load()

        assert result.is_success
        config = result.value
        # Should load all environment variables
        assert isinstance(config, dict)
        assert len(config) > 0  # Should have some env vars

    def test_save_environment_variables(self) -> None:
        """Test saving to environment variables."""
        config_data = {
            "TEST_VAR": "test_value",
            "ANOTHER_VAR": "another_value",
        }

        adapter = EnvironmentConfigAdapter()
        result = adapter.save(config_data)

        assert result.is_success

        # Verify variables were set
        assert os.environ.get("TEST_VAR") == "test_value"
        assert os.environ.get("ANOTHER_VAR") == "another_value"

        # Cleanup
        os.environ.pop("TEST_VAR", None)
        os.environ.pop("ANOTHER_VAR", None)

    def test_prefix_filtering(self) -> None:
        """Test prefix filtering functionality."""
        test_env = {
            "MYAPP_CONFIG_VAR": "value1",
            "MYAPP_SETTING": "value2",
            "OTHER_VAR": "value3",
            "DIFFERENT_VAR": "value4",
        }

        with patch.dict(os.environ, test_env, clear=False):
            adapter = EnvironmentConfigAdapter(prefix="MYAPP_")
            result = adapter.load()

            assert result.is_success
            config = result.value

            # Should only contain MYAPP_ prefixed variables
            myapp_vars = [k for k in config if k.startswith("MYAPP_") or not k.startswith(("OTHER_", "DIFFERENT_"))]
            assert len(myapp_vars) >= 2  # Should have at least our test vars

    def test_case_sensitivity(self) -> None:
        """Test case sensitivity in environment variable handling."""
        test_env = {
            "FLEXT_test_var": "lowercase",
            "FLEXT_TEST_VAR": "uppercase",
        }

        with patch.dict(os.environ, test_env, clear=False):
            adapter = EnvironmentConfigAdapter(prefix="FLEXT_")
            result = adapter.load()

            assert result.is_success
            config = result.value
            # Both should be preserved (case sensitive)
            assert len([k for k in config if "test_var" in k.lower()]) >= 1


class TestDatabaseConfigAdapter:
    """Test DatabaseConfigAdapter functionality."""

    def test_database_adapter_initialization(self) -> None:
        """Test DatabaseConfigAdapter can be initialized."""
        # Mock database connection
        mock_connection = Mock()
        adapter = DatabaseConfigAdapter(mock_connection)

        assert adapter is not None
        assert hasattr(adapter, "load")
        assert hasattr(adapter, "save")

    def test_load_from_database(self) -> None:
        """Test loading configuration from database."""
        # Mock database that returns config data
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_cursor.fetchall.return_value = [
            ("project_name", "test-project"),
            ("environment", "development"),
            ("debug", "true"),
        ]

        adapter = DatabaseConfigAdapter(mock_connection)
        result = adapter.load()

        assert result.is_success
        config = result.value
        assert config["project_name"] == "test-project"
        assert config["environment"] == "development"
        assert config["debug"] == "true"

    def test_save_to_database(self) -> None:
        """Test saving configuration to database."""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor

        config_data = {
            "project_name": "test-project",
            "environment": "production",
        }

        adapter = DatabaseConfigAdapter(mock_connection)
        result = adapter.save(config_data)

        assert result.is_success
        # Verify database operations were called
        mock_connection.cursor.assert_called()
        mock_cursor.execute.assert_called()

    def test_database_connection_error(self) -> None:
        """Test handling database connection errors."""
        # Mock connection that raises exception
        mock_connection = Mock()
        mock_connection.cursor.side_effect = Exception("Database connection failed")

        adapter = DatabaseConfigAdapter(mock_connection)
        result = adapter.load()

        assert not result.is_success
        assert "connection" in result.error.lower() or "database" in result.error.lower()

    def test_database_empty_result(self) -> None:
        """Test handling empty database results."""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_cursor.fetchall.return_value = []  # Empty result

        adapter = DatabaseConfigAdapter(mock_connection)
        result = adapter.load()

        assert result.is_success
        assert result.value == {}  # Should return empty dict


class TestAdapterIntegration:
    """Test adapter integration and usage patterns."""

    def test_adapter_chaining(self, tmp_path: Path) -> None:
        """Test chaining multiple adapters."""
        # Setup file adapter
        env_file = tmp_path / ".env"
        env_file.write_text("PROJECT_NAME=file-project\nENVIRONMENT=development")

        file_adapter = FileConfigAdapter(str(env_file))
        env_adapter = EnvironmentConfigAdapter(prefix="TEST_")

        # Load from file
        file_result = file_adapter.load()
        assert file_result.is_success

        # Set environment override
        with patch.dict(os.environ, {"TEST_PROJECT_NAME": "env-project"}):
            env_result = env_adapter.load()
            assert env_result.is_success

            # Environment should override file
            file_config = file_result.value

            assert file_config["PROJECT_NAME"] == "file-project"
            # env_config might have TEST_PROJECT_NAME or PROJECT_NAME depending on processing

    def test_adapter_fallback_chain(self) -> None:
        """Test adapter fallback pattern."""
        # Primary adapter (fails)
        primary_adapter = FileConfigAdapter("/non/existing/file.env")
        primary_result = primary_adapter.load()
        assert not primary_result.is_success

        # Fallback adapter (succeeds)
        fallback_adapter = EnvironmentConfigAdapter()
        fallback_result = fallback_adapter.load()
        assert fallback_result.is_success

        # Application would use fallback when primary fails
        final_config = fallback_result.value if not primary_result.is_success else primary_result.value
        assert isinstance(final_config, dict)

    def test_adapter_configuration_merging(self, tmp_path: Path) -> None:
        """Test merging configurations from multiple adapters."""
        # File config
        env_file = tmp_path / ".env"
        env_file.write_text("PROJECT_NAME=test\nDEBUG=true")

        file_adapter = FileConfigAdapter(str(env_file))
        file_result = file_adapter.load()

        # Environment config
        test_env = {"OVERRIDE_SETTING": "env_value"}
        with patch.dict(os.environ, test_env):
            env_adapter = EnvironmentConfigAdapter()
            env_result = env_adapter.load()

            # Merge configurations
            merged_config = {}
            if file_result.is_success:
                merged_config.update(file_result.value)
            if env_result.is_success:
                merged_config.update(env_result.value)

            # Should have both file and environment values
            assert "PROJECT_NAME" in merged_config
            assert "OVERRIDE_SETTING" in merged_config


class TestAdapterErrorHandling:
    """Test error handling across all adapters."""

    def test_file_adapter_permission_error(self) -> None:
        """Test file adapter handles permission errors."""
        adapter = FileConfigAdapter("/root/.env")  # Likely no permission
        result = adapter.load()

        # Should handle gracefully (might succeed if readable, fail if not)
        if not result.is_success:
            assert "permission" in result.error.lower() or "access" in result.error.lower()

    def test_environment_adapter_invalid_data(self) -> None:
        """Test environment adapter handles invalid data."""
        # Environment variables are always strings, so this is mostly about format
        adapter = EnvironmentConfigAdapter()

        # Save invalid data type (should convert to string)
        result = adapter.save({"TEST_NUM": 123, "TEST_BOOL": True})

        if result.is_success:
            # Should convert to strings
            assert os.environ.get("TEST_NUM") == "123"
            assert os.environ.get("TEST_BOOL") == "True"

            # Cleanup
            os.environ.pop("TEST_NUM", None)
            os.environ.pop("TEST_BOOL", None)

    def test_database_adapter_sql_injection_protection(self) -> None:
        """Test database adapter protects against SQL injection."""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor

        # Malicious config data
        malicious_data = {
            "project_name": "test'; DROP TABLE config; --",
            "environment": "development",
        }

        adapter = DatabaseConfigAdapter(mock_connection)
        result = adapter.save(malicious_data)

        # Should use parameterized queries (check mock calls)
        if result.is_success:
            # Verify that execute was called with parameters (not direct string interpolation)
            calls = mock_cursor.execute.call_args_list
            for call in calls:
                args, kwargs = call
                # Should have parameters (second argument to execute)
                assert len(args) >= 2 or "parameters" in kwargs
